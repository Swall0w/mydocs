====================================
Linux システム関連
====================================

:著者: Masato

概要
====================================
データベースの構築から、インストール、ipの固定までのhow to をまとめていきます。

データベース
====================================

Linux 状態確認
====================================

Top コマンド
------------------------------------
topコマンドで得られる情報は大きく分けて二つある。

* システム全体の負荷
* プロセス、CPU、メモリ、スワップの統計情報

使い方と操作方法
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
通常鵜はtopと打つだけだが、他にも引数がある。 ::
    
    $ top           # CPU使用率順にソート
    $ top -a        # メモリ使用順にソート
    $ top -p [PID]  # 特定のプロセスを監視
    $ top -d1       # 1秒ごとに更新

操作方法

* Shift+o: 表示された特定のキーを押してエンターすると、任意の列でソートできる。
* Shift+p: CPU使用率順にソート
* Shift+m: メモリ使用率順にソート

ヘッダーの見方
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
load average ::

    top - 08:42:47 up 2min,  2 users,  load average: 2.76, 0.76, 0.27
    #     現在時間 サーバーの  ログイン              1分   5分   15分
    #              稼働時間   ユーザー数              間の単位時間あたりの待ちタスク数

uptimeコマンドと同じ結果が返ってくる。

Tasks ::

    Tasks: 110 total,   7 running, 103 sleeping,   0 stopped,   0 zombie
    #      合計タスク数   稼働中       待機中        停止タスク    ゾンビタスク

各状態のタスクの数を見ることが出来る。

CPU ::

    Cpu(s): 77.1%us,  8.4%sy,  0.0%ni,  0.1%id, 14.3%wa,  0.0%hi,  0.2%si,  0.0%st
    #       user      system    nice     idle   I/O wait hardware  software  steal
    #                                                    interrupt interrupt

* ni: niceで実行優先度を変更したプロセスがユーザーモードでCPUを消費した時間
* st: OS仮想化利用時に他の仮想CPUの計算で待たされた時間

sarのようにCPUの利用時間の割合をプロセスの種類ごとに見ることが出来る。
1を押すと、CPUごとの情報が見れる。

Memory/Swap ::

    Mem:  15144564k total,  1178112k used, 13966452k free,    28300k buffers
    Swap:        0k total,        0k used,        0k free,   289928k cached

* buffers: mallocなどでバッファとして利用されているメモリ量
* cached : キャッシュとして利用されているメモリ量（ファイルシステムのキャッシュ）

物理メモリとスワップ領域の使用状況が見れる。freeコマンドでも同じ結果となる。

プロセス一覧 

======= =========== =========== =========== =========== ======= =========== ============== ================
PR       NI          VIRT          RES      SHR          S           %CPU     %MEM            TIME+
======= =========== =========== =========== =========== ======= =========== ============== ================
優先度  相対優先度  仮想メモリ  物理メモリ  共有メモリ  状態    CPU使用率   メモリ使用率    実行時間
======= =========== =========== =========== =========== ======= =========== ============== ================

* NI    : Nice value 相対優先度。0が基準で、負だと優先度が高く、正だと優先度が低い。
* VIRT  : Virtual Image 確保された仮想メモリ全て。スワップしたメモリを含む。
* RES   : Resident size スワップしていない、使用した物理メモリのサイズ
* SHR   : Shared Mem size 他のプロセスと共有される可能性のあるメモリのサイズ
* S     : Process Status 以下のいずれかの状態であるかを示している。

    - D :割り込み不能
    - R : 実行中
    - S : スリープ中
    - T :停止中
    - Z :ゾンビプロセス

Linux バージョン確認
====================================

Cent OS
------------------------------------
Cent OSのバージョン確認::

    $ cat /etc/redhat-releace
    CentOS release 6.8 (Final)

アーキテクチャを確認する。
------------------------------------
OSのバージョン確認コマンド::

    $ arch
    X86_64 <- 64bitの場合
    i686   <- 32bitの場合
    $ uname -a

FTPコマンドでファイル転送
====================================
FTPコマンドは、ホスト名とポート番号を指定して起動します。すると、ユーザ名とパスワードを聞いてくるので入力します。ユーザ認証がOKな場合は各種FTPコマンドが使えます。

================ ====================================================
fptコマンド         機能
================ ====================================================
ftp                 FTPを起動する。
ls                  リモートのファイルの一覧を表示
pwd                 リモートのカレントディレクトリを表示
cd                  リモートのカレント作業ディレクトリを表示
mkdir               リモートのディレクトリを作成
!ls                 ローカルのファイルの一覧を表示
!pwd                ローカルのカレントディレクトリを表示
!cd                 ローカルのカレント作業ディレクトリを移動
get                 ファイルをダウンロード
mget                複数のファイルをダウンロード
put                 ファイルをアップロード
mput                複数のファイルをアップロード
passive             Passiveモードの切り替え
bin /binary         バイナリ転送モードに切り替え
asc /ascii          ASCII転送モードに切り替え
bye /exit /quit     FTPコマンド終了

================ ====================================================

Ubuntuにpukiwikiインストール
====================================

Apach2.4 & PHP インストール
------------------------------------
普通にapt-getする。::

    $ sudo apt-get install apache2
    $ sudo apt-get install php

/var/www/htmlがデフォルトのパブリックフォルダとなっている。apt-getでインストール後は自動的にサーバプロセスが起動する。ブラウザで、::

    http://[サーバー名]/
    http://localhost/index.html

へアクセスし、Apacheのデフォルトページが表示されればOK

PukiWiki1.5.0を設置
------------------------------------
utf8版のPukiWikiを使う。WikiのURLは、http://[サーバー名]/wiki とする。zipファイルなので、unzipする。::

    $ sudo apt-get install unzip
    $ cd /var/www/html/
    $ sudo unzip pukiwiki-1_5_0_utf8.zip
    $ sudo mv pukiwiki-1_5_0_utf8 wiki

Wikiの実効権限をサーバプロセスと同じ、www-dataにする。::

    $ chwon -R www-data.www-data /var/www/html/wiki

これで http://[サーバ名]/wiki にアクセスし、Pukiwikiのデフォルトページが表示される。

http://qiita.com/tuneyukkie/items/e7565fb0856e6a9f517d


Linux ファイルシステム
====================================

/proc
------------------------------------

プロセスやメモリなどのLinuxシステム上のリソース関連情報をあたかもファイルであるかのように配置した
仮想的なファイルシステム、ファイルを読もうとしたときにOSが動的に生成する
大体が読み取り可能だが書き込み可能のものもあって(代表的なものは/proc/sys)
そのファイルを利用すればカーネルのパラメータを変更できる

/procの分類
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
大きくわけて/proc内にはプロセスIDの数字が書かれたディレクトリとLinuxのカーネル内部情報(cpu関連、メモリ関連等)があるpsやunameなどのコマンドが情報を出力する際に直接参照されている。
各ファイルはcatなどで参照できる(/proc/kcoreはメモリのイメージでバイナリなので止めた方がいい)

Linuxのカーネル内部情報
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

=========== ==============================================================================
apm          APMの情報
acpi         ACPI(パソコンの電源管理)の情報
bus          バスの情報を含むディレクトリ
cmdline      カーネルのブートパラメータ
cpuinfo      CPU情報
devices      使用可能なブロック/キャラクタデバイス
dma          DMAチャネル情報
filesystems  サポートするファイルシステム
interrupts   割り込み情報
ioports      I/Oポート情報
iomem        マシンのメモリ使用状況
irq          割り込み情報
kcore        物理メモリのイメージ
kmsg         カーネルのメッセージ
loadavg      負荷情報
locks        カーネル・ロック情報
meminfo      メモリ情報
misc         雑多な情報
modules      ロードされたモジュールの一覧情報
mounts       マウントされたファイルシステムの一覧
net          ネットワークに関する設定を含むディレクトリ
pci          PCIデバイスのリスト
partitions   システムが認識したパーティション情報
scsi         SCSIデバイスの情報を含むディレクトリ
self         カレントプロセスへのシンボリックリンクを含むディレクトリ
stat         カーネル全体の統計情報
slabinfo     スラブキャッシュの状態
swaps        スワップの利用状況
sys          ネットワークやファイル・アクセスなどの設定を含むディレクトリ
uptime       システムの駆動時間
version      Linuxカーネルのバージョン
=========== ==============================================================================

各プロセスIDが書かれたディレクトリ以下
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
=========== ==============================================================================
cmdline     コマンドライン引数
environ     環境変数の値
fd          全てのファイルディスクリプタを含んだディレクトリ
mem         プロセスが保持するメモリ
stat        プロセスの状態
status      statの表示の可読性を高めたもの
cwd         プロセスの現在の作業ディレクトリへのリンク
exe         このプロセスの実行形式へのリンク
maps        メモリマップ
root        該当プロセスへのルートディレクトリへのリンク
statm       プロセスのメモリ状態
=========== ==============================================================================

サーバー管理
====================================

ログイン回避
------------------------------------
アカウントがない状態で、ログインしなければならない場合の対処法について記す。コンソールアクセスが可能で再起動してもいいのであれば、
シングルユーザーモードでブートすればよい。Crtl-Alt-Deleteキーを押した後は単にPOST(Power On Self Test:電源投入時や再起動時に自動的に行われるメモリなどのテスト)が実行されるのを待ち、
カーネルのブート時に **single** というパラメータを渡す。例えば、LILOプロンプトの場合は、::

    LILO: linux singel

でrootのシェルを起動出来るが、RedHatでは使えないときがある。その時は、::

    LIL: linux init=/bin/bash
    # mount -o remount,rw /

とし、起動する。この状態ではネットワークはダウンしており、通常のデーモンは全く起動していないので、パスワードの再設定や1つ2つのファイルに手を加える程度である。
得に、Ctrl-Dや **exit** と入力しない。::
    
    # mount -o remount,ro /

をする必要がある。というのも、initが起動していないため、システムを安全に停止するためにあるプロセスがない。よって読み込み専用でシャットダウンをする。
ブートパラメータは調べるとよりおもしろいので、後で調べる。例えば、::
    
    LILO: linux single init=/bin/bash rw

と表現することも出来る。

Amazon Linux
====================================
cuda構築するときの参考 http://qiita.com/pyr_revs/items/e1545e6f464b712517ed

Caffeの構築
------------------------------------
https://gist.github.com/rezoo/a1c8d1459b222fc5658f

yumで入れられるもの
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
できる限りyumで入れる。 ::

    $ sudo yum install protobuf-devel snappy-devel

Atlasインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Numpyで演算に使用されるatlasをインストールする。 ::

    $ sudo yum install atlas-sse3-devel.x86_64

環境変数ATLAS,BLAS,LAPACKを設定する。 $HOME/.bashrcに記述する。 ::

    export ATLAS=/usr/lib64/atlas-sse3/libatlas.a
    export BLAS=/usr/lib64/atlas-sse3/libcblas.a
    export LAPACK=/usr/lib64/atlas-sse3/liblapack.a

Boostインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
caffeのPythonラッパはboost-pythonというライブラリで開発されている。 
そのため、Boostライブラリが必要になる。 BoostはCaffeでも必要なので、boost-pythonだけでなく全部入れる。 ::

    $ sudo yum install boost-devel.x86_64


Anacondaインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AnacondaはPythonにデータ解析等で使用するライブラリがContinuum Analytics社があらかた準備されているものです。後から自分で入れるものが減るので、使えるならこちらを使う。
https://www.continuum.io/downloads 
インストール後に$HOME/.bashrcの末尾に ::

    xport PATH=$HOME/anaconda/bin:$PATH
    export LD_LIBRARY_PATH=$HOME/anaconda/lib:$LD_LIBRARY_PATH

を記述する。anacondaが勝手にやるが、もし出来てなかったら自分でやる。
opencvもcondaで入れることが出きるので、こちらからもやる。 ::

    $ conda update opencv

また、condaからpipをインストールすることで、pip経由でインストールできる。 ::

    $ conda install pip

Protocol Bufferをインストールする。 ::

    $ pip install protobuf

OpenCVインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
opencvはcmakeでビルドするため、yumでインストールする。 ::

    $ sudo yum instal cmake

Linux版のアーカイブを公式からダウンロードする。解凍したディレクトリで以下のコマンドを実行していく。 
http://opencv.org/downloads.html ::

    $ mkdir build
    $ cd build/
    $ cmake ..
    $ make
    $ sudo make install

glogインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
glogのアーカイブをダウンロードし、ビルドする。 https://code.google.com/p/google-glog/ ::

    $ ./configure
    $ make 
    $ make check
    $ sudo make install

gflagsインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
gflagsのアーカイブをダウンロードし、ビルドする。https://code.google.com/p/gflags/ ::

    $ mkdir build
    $ cd build/
    $ CXXFLAGS="-fPIC" cmake ..
    $ make
    $ sudo make install

-fPICをつけておかないと、caffeにリンクすることが出来ないので注意。

leveldbインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
leveldbのアーカイブをダウンロードし、ビルドする。 https://code.google.com/p/leveldb/ ::

    $ make
    $ make check
    $ cd ..
    $ sudo mv leveldb-1.15.0 /opt/leveldb
    $ sudo cp -r leveldb/include/leveldb /usr/local/include

これでダメだったので、その時の対処について述べる。 ::
    
    -fPICオプション付きでコンパイルするように言われたので、
    MakefileのCFLAGSをいじる。
    CFLAGS = -c -I ...... $(OPT) -fPIC

これで再度makeする。また、ライブラリについても共有する必要があるので、makeした後にできる

hdf5インストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
hdf5のアーカイブをダウンロードし、ビルドする。
https://support.hdfgroup.org/HDF5/release/obtainsrc.html ::

    $ ./configure --prefix=/usr/local/hdf5 --enable-fortran --enable-cxx
    $ make 
    $ make check
    $ sudo make install
    $ sudo make check-install

lmdbインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
gitoriousのリポジトリからソースコードを取得し、ビルド、インストールする。 https://gitorious.org/mdb/mdb ::

    $ git clone https://gitorious.org/mdb/mdb.git
    $ cd mdb/libraries/liblmdb/
    $ make -j8
    $ make -j8 test
    $ sudo mkdir /usr/local/man
    $ sudo make install

Caffeインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
githubからcaffeのコードを取得し、ビルドする。https://github.com/BVLC/caffe.git ::

    $ git clone https://github.com/BVLC/caffe.git
    $ cd caffe
    $ cp Makefile.config.example Makefile.config

Makefile.configでpython、atlas、GPU、CPU設定をする。 ::

    $ make all
    $ make test
    $ make runtest

runtestをするために、環境変数の設定が必要である。(.bashrcに追記) ::
    
    export LD_LIBRARY_PATH=/usr/local/lib/:$LD_LIBRARY_PATH
    export LD_LIBRARY_PATH=/opt/leveldb:$LD_LIBRARY_PATH
    export LD_LIBRARY_PATH=/usr/local/hdf5/lib:$LD_LIBRARY_PATH

make runtestをして、エラーがでなければ、正常にビルドが完了している。次にpython用のcaffeパッケージをビルドする。
そのために、 ::

    $ make pycaffe

をし、PYTHONPATH環境変数にcaffeのpythonディレクトリを塚することも必要。
pythonを起動し、 ::

    >>> import caffe

でエラーがでなければ大丈夫。Protocol buffer関係のエラー出た場合は多分protobufパッケージをインストールしていないだけなのでインストールする。


linux カーネル
====================================

linux カーネルの機能
------------------------------------
Linuxは，フィンランド・ヘルシンキ大学の学生だったLinus Torvalds氏が，i386プロセッサの勉強のために作成したオペレーティング・システム（OS）です。1991年に誕生しました。当初はネットワーク機能すらない貧弱なOSでしたが，いまや企業の基幹業務にも使われる実用的なOSとして成長しています。これは，Torvalds氏をはじめとした多くの開発者が，Linuxの改良に取り組んできた結果です。

Linuxが誕生した1990年代は，ネットワーク機能を標準装備したWindowsシステムの登場や商用ISPのサービス開始により，インターネットが爆発的に普及した時代です。それと同時に一般家庭にもパソコンが浸透し，広く利用されるようになった時代でもありました。

その一方で，コンピュータの仕組みや動作を理解する人の割合は年々減ってきているように思います。LinuxやWindowsなどの現代的なOSは，ハードウエアやOSの構造を知らなくても簡単にアプリケーションの作成ができる環境を提供してくれます。GUIも充実し，ユーザーにとっては利用しやすい環境になっています。

この状況は自動車に似ています。自動車が登場した頃は，自動車の構造をよく知っている人しか利用できませんでしたが，現在では自動車の内部構造を深く知らなくても，簡単に運転できる機構が用意されています。

しかし，自動車の性能を余すところなく利用するには，内部構造のきちんとした理解が必要です。同様に，コンピュータの性能を発揮させるには，利用者に対して隠ぺいされている部分の理解が必要です。コンピュータの仕組みや動作を理解することにより，性能上

Linuxとは何か，こう聞かれたときに私は「コンピュータのオペレーティング・システム（OS）の一つです」と答えます。では，OSとはいったいどのようなものなのでしょうか。OSを一言でいうと「ユーザー・アプリケーションに実行環境を提供するソフトウエア」になります。しかし，これでは簡潔過ぎて何だか分かりませんので，もう少し具体的に見てみましょう。

例えば，コンピュータにログインする場合を考えてください。ログイン時には，キーボードからユーザーIDを入力します。入力した文字は画面に表示されます。このような動作が可能なのは，当然ですがログイン用のソフトウエアが，これらの処理を行うようにプログラムされているからです。

ところが，実際には，ログイン用ソフトウエアは，キーボードの入力信号を判定したり，画面へのドット出力を制御するようにはプログラムされていません。キーボード入出力や画面出力のような基本的な処理を個々のソフトウエアで実装するのは，無駄が多く手間もかかるからです。例えば，キーボードやビデオ・カードなどの種類によってプログラムを書き分けねばなりません。

代わりにこれらのソフトウエアには，「入力デバイスから文字を受け取る」や「出力デバイスに文字を出力する」という抽象的命令が記述されています。これらの命令を受け取って，実際にキーボードの入力を制御したり，画面に表示したりするのがOSの仕事です。

ハードウエアの制御をOSが肩代りすることで，アプリケーションの作成が容易になります。

またOSは，指示に従ってディスクからソフトウエアをメモリーに読み込んで実行させるといった補助的な仕事も行います。これにより，プログラマはソフトウエア作成時にこのような部分まで作り込む必要がなくなります。

コンピュータの登場初期は，各ソフトウエアごとに独自にハードウエアの制御をしていました。しかし，これでは効率が悪いため，OSという共通インフラが整備されたのです。OSの登場により，アプリケーションの開発が楽になると同時に，ハードウエアの細かな違いをOSが吸収し，同じプログラムをさまざまなコンピュータ上で実行できるようになりました。

OSの中心であるカーネル
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
OSの中でも，特に中心となるものが「カーネル（kernel）」です。カーネルというのは英語で「核」という意味で，文字通りOSの一番重要な部分を指します。なお，OSは，広義ではカーネルや基本ライブラリ・基本ツールを含む総称として用いられますが，狭義にはカーネルのみを指します。カーネルにはOSのエッセンスが詰まっているのです。先程のように，アプリケーションからの命令を受け取ってハードウエアを制御するのは，すべてこのカーネルの仕事です。

このカーネルの機能の違いがOSの性質を表すといっても過言ではありません。例えば，MS-DOSで利用されているカーネルは，アプリケーションが直接ハードウエアを制御することを許可しています。柔軟な制御が可能ですが，アプリケーションのバグがシステム破壊をもたらす可能性があります。これに対しLinuxでは，原則としてカーネルを通じてのみハードウエアを制御できます。危険な操作はカーネルでブロックできるため，システムの安全性は高いと言えます。

現代的なOSのカーネルは一般的に，次のような6つの主要機能を備えています。カーネルがこれらの機能を必要に応じて提供することで，高度な機能を持つアプリケーションが安全に稼働できるのです。

======================= =============================================================================================================================================
カーネルが提供する機能      解説
======================= =============================================================================================================================================
プロセス管理            システム上で動作するアプリケーション・プログラムの実行を制御する。ユーザーがアプリケーションを起動すると、その1つひとつはプロセスとなり
                        カーネルにより管理される。書くプロセスごとに独自の実行環境を割り当てて、マルチタスクを実現する。
空間管理                システムに搭載しているメモリーを管理する。プロセッサがもつ機能を利用して、プロセスごとに仮想的なメモリー空間(VM)を作り、そのメモリ割り当てを
                        行う。メモリーが足りなくなると、その一部をディスクに退避させたりし、メモリーを効率的に利用できるようにする。
時間管理                システム実行時の時間を管理する。特定の時間が経過したら、処理を行う時限処理を行ったり、システムの現在時刻を計算したりして、時間の管理をする。
割り込み管理            ハードウェアからの信号を受け取ってプログラムを起動する割り込みの制御をする。キーボードの入力やディスクの入出力、ネットワークパケットの送受信
                        など、コンピュータに接続されているハードウェアの多くは、割り込み機能を利用して、データの入出力を通史する。割り込み管理では各種割り込みに
                        応じた制御をする。
ファイル・システム      アプリケーションやデータなどはファイルとして保存する。カーネルはこのファイルを格納するためのファイル・システムという論理的なデータと、
                        ディスクに書き込むことが出来るディスク・ブロックを対応付ける役割を持っている。
ネットワーク            インターネット・プロトコル(IP)を始めとした、様々なプロトコルによるネットワーク通信機能を提供する。
======================= =============================================================================================================================================

カーネルは，コンピュータが起動したときに一番最初に動作するプログラムです。カーネルは，コンピュータのさまざまなハードウエアを初期化し，アプリケーションの動作環境を整えます。しかしそのあとは，カーネルは何もしない状態になります。なぜなら，カーネルはアプリケーションが動作するための補助的な仕事をしますので，自発的に動作をする必要がほとんどないからです。後述するアプリケーションからのシステム・コールやハードウエアからの割り込み信号などにより動作する，イベント駆動型のソフトウエアなのです。

これらカーネル一般の特徴に加えて，Linuxカーネルにはさまざまな特徴があります。オープンソースであることや対応プラットフォームが多いなど，他のOSのカーネルにはないLinux独特のものもあります。主な特徴を次に挙げました。

============================= =======================================================================================================================================
特徴                             解説
============================= =======================================================================================================================================
マルチタスクに対応              マルチタスクとは同時に複数のプログラムを動作させる機能である。カーネルには、複数のプログラムが競合せずに動作する仕組みがある。
マルチユーザーに対応            複数のユーザーが同時にシステムを利用できす。セキュリティを確保するために、ユーザーごとにファイルの読み書き権限を設定出来る。
POSIX規格に準拠                 POSIX(Portable Operating System Interface)とは、OSとアプリケーション間の標準インターフェースを定めた規格である。
                                IEEE(アメリカ電気電子学会)が中心となって策定する。OSがPOSIXに準拠することで、他のOSとアプリケーションのソースコードレベルの互換性が
                                取りやすくなっている。
モノリック・カーネルを採用      伝統的なUNIXと同じくモノリシック・カーネルを採用している。モノリスとは一枚岩のことであり、カーネル全体が1つのプログラムを意味する。
モジュールの動的ロードに対応    動的な機能を追加・削除するためのカーネル・モジュール機構を持っている。これにより、再起動せずに新しい機能を追加したり、使わない機能
                                を取り外してリソースを有効活用出来る。
オープンソースである            LinuxはGNU GPL(General Public License)というオープンソース・ライセンスを基に配布されている。
                                ソースコードは誰でも見ることができ、改善したものを自由に再配布できる。
多くのアーキテクチャに対応      数多くのアーキテクチャに対応している。20種類以上に対応している。
開発速度が早い                  開発がバザール方式で行われてるため、進化の速度が早いのが特徴である。開発メーリングリストには、たくさんのパッチが投稿される。
============================= =======================================================================================================================================

システムコールの機能
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Linuxでは，アプリケーションはハードウエアを直接制御することはできません。前述した通り，カーネルを通じてハードウエアを制御します。それではアプリケーションは，どのようにしてカーネルに指示を出すのでしょうか。

Linuxカーネルには「システム・コール」とよばれる，アプリケーションから呼び出し可能なプログラム群が用意されています。アプリケーションは，このシステム・コールを呼び出すことでカーネルに指示を出し，カーネルの機能を利用できるのです。

**図**

アプリケーションは，システム・コールを呼び出すことでカーネルの機能を利用できます。

例えば，ファイルを読み書きするには，まずファイルをオープンする必要があります。ファイルは一般にハード・ディスクに収められていますが，アプリケーションからは直接ハード・ディスクにアクセスできません。そこで，openシステム・コールを発行＊2し，カーネルに目的のファイルを使いたい旨を伝えます。するとカーネルは，そのファイルを利用する権限をアプリケーションに与えます。また，LinuxはマルチタスクOSですから，複数のアプリケーションが同時にファイルをオープンしないようにする仕組みも必要です。この仕組みは，flockシステム・コールが提供しています。

システム・コールがない場合には，アプリケーションはファイルが置かれているファイル・システムの違いや，物理デバイスの違い（ハード・ディスクなのか，フロッピ・ディスクなのか，CD-ROMなのか）を意識してアクセスしないといけません。排他制御も十分に行えず，ファイル破壊などの危険も生じます。

システム・コールを用意しておき，こういった処理をカーネル内部で行うことにより，アプリケーションは「ファイルを読む」といった仕事に集中できるわけです。そのほかにも，時刻を知るシステム・コールやネットワーク入出力用のシステム・コールなど，たくさんのシステム・コールが存在し，その数は200を超えます。システム・コールの一覧は/usr/include/asm/unistd.hファイルに記述してあります。

カーネル・モードとユーザー・モード
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
しかし、システム・コールを使わないと，なぜアプリケーションはハードウエアにアクセスできないのでしょうか。

それは，アプリケーションが，通常は「ユーザー・モード」と呼ばれる制限モードで動作しているからです。ユーザー・モードでは，カーネル内部の情報やハードウエアを直接参照することは禁止されています。

これに対し，システム・コールを発行して，カーネル内部のプログラムを実行しているときは，メモリー空間やハードウエアへのアクセスが自由な「カーネル・モード」と呼ばれる特権モードに切り替わります。そして，ハードウエアへのアクセスなど，特権が必要な処理を行った後，システム・コールが終了し，アプリケーションの動作は再び「ユーザー・モード」に戻ります。

**図**

システム・コールを呼び出すと，カーネル・モードに切り替わり，ハードウエアに直接アクセスできるようになります

このように動作モードを分けることにより，ユーザー・モードで実行しているときに重大なミスを犯しても，システム全体に悪影響が及ばないようになっているのです。例えば，アプリケーションでの利用が許可されていないメモリー・アドレスにアクセスしても，カーネルが「Segmentation Fault」というエラーを出してアプリケーションを強制終了できます。このとき，他のアプリケーションには何の影響もありません。

カーネルのこの機能は，最近のプロセッサに備わっている，権限レベルを複数設定する保護機能を利用しています。例えば，x86互換プロセッサは0～3までの4つの権限レベルを持ち，Linuxではカーネルが最高権限のレベル0，アプリケーションは最低権限のレベル3で動作するようになっています。

ハードウェアをファイルで提供
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
カーネルの中で，最もハードウエアに近く，ハードウエアの制御を行う部分がデバイス・ドライバです。デバイス・ドライバはハードウエアを制御すると共に，性質の似たハードウエアをひとまとめに抽象化し，共通の手続きでカーネルやアプリケーションから利用できるようにします。

LinuxなどのUNIX系OSでは，ハードウエアを「キャラクタ・デバイス」と「ブロック・デバイス」の2つに大別して抽象化します。

キャラクタ・デバイスは，データの読み書きを1バイト（1キャラクタ＊3）ずつ順に行うハードウエアを抽象化したものです。デバイス・ドライバではデータの入出力順を変更したりせず，ユーザー・アプリケーションとハードウエアが直接データをやり取りする形になります。最も基本的なデバイスの抽象化形式と言え，ほとんどすべてのデバイスをキャラクタ・デバイスとして取り扱うことができます。Linuxでは，サウンド・カードやシリアル・ポートなどをキャラクタ・デバイスとして利用します。

これに対しブロック・デバイスは，データの読み書きをブロック単位で行うハードウエアを抽象化したものです。ブロック・デバイスの最大の特徴は，カーネル空間内の固定長のバッファ（一時記憶領域）を経由して入出力を行うことです。これにより，デバイス上の不連続な位置に記録されているデータへアクセスする「ランダム・アクセス」に対応しやすくしたり，処理の高速化が実現できます。また，ブロック・デバイス上には，ファイル・システムを構築できるのも特徴の1つです。Linuxでは，ハード・ディスク・ドライブやCD-ROMドライブなどをブロック・デバイスとして利用します。

これらのデバイスは，2種類の番号を付けて管理されます。サウンド・デバイスやIDEデバイスといったデバイスの種類を示すのが「メジャー番号」で，同じメジャー番号のデバイス同士を区別するための番号が「マイナー番号」です。メジャー番号とマイナー番号には，それぞれ0～255までの数値が使用可能です。

UNIX系OSでは，デバイスへの入出力は「デバイス・ファイル」という特殊な形式のファイルを通じて行います。デバイスをファイルとして提供することで，ファイルを扱うのと同じ手順でアプリケーションからデバイスを扱えるメリットがあるからです。

デバイス・ファイルは，原則として/devディレクトリに配置する決まりになっています。以下のように，-lオプション付きでlsコマンドを実行することでデバイス・ファイルの属性を調べられます。ファイル・タイプが「c」になっているものがキャラクタ・デバイス，「b」になっているものがブロック・デバイスです。メジャー番号とマイナー番号も表示されています。 ::

    % ls -l /dev
    total 0
    crw-------  1 root root     10, 175 Mar 16 23:21 agpgart
    crw-rw----  1 root tty       7,   2 Mar 16 23:21 vcs2
    rw-rw----  1 root tty       7,   6 Mar 16 23:21 vcs6
    rw-rw----  1 root tty       7,   7 Mar 16 23:21 vcs7
    rw-rw----  1 root tty       7, 128 Mar 16 23:21 vcsa
    w-rw----  1 root tty       7, 129 Mar 16 23:21 vcsa1
    drwxr-xr-x  2 root root          60 Mar 16 23:21 vfio
    crw-------  1 root root     10,  63 Mar 16 23:21 vga_arbiter
    crw-rw-rw-  1 root root      1,   5 Mar 16 23:21 zero
    デバイスの種類        メジャー番号、マイナー番号

lsコマンドを-lオプション付きで実行すると，デバイス・ファイルのデバイス・タイプやメジャー番号，マイナー番号などが分かります。

ただし，すべてのデバイスがファイルとして提供されるわけではありません。ネットワーク・デバイスは上記2つのデバイスとは違った方法で提供されています。

動作例
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
実際のアプリケーションの動作時にカーネルがどのような仕事をしているのかを具体的に見てみましょう

アプリケーションがファイルからデータを読み込む際の内部処理を以下図に挙げました

**図** 

ここではハード・ディスク上のファイルへのアクセスを例に挙げていますが，システム・コールやシステム・ライブラリを通じてアクセスしているため，他のデバイス上のファイルにも同様の手順でアクセスできます。

この際の処理の流れは次のようになります。（1）アプリケーションがシステム・ライブラリのfread（）関数を呼び出して，ファイルの読み込みを指示。（2）fread（）関数内からread（）システム・コールを発行。（3）ファイル・システムを通じてカーネルが，デバイス・ドライバにファイルの読み込みを指示。（4）デバイス・ドライバがファイルの内容をカーネル内のバッファにコピー。（5）read（）システム・コールが終了し，ファイルの内容がシステム・ライブラリ内のバッファにコピー。（6）fread（）関数が終了し，内容がアプリケーションのバッファにコピーされると処理が終了です。

また，アプリケーションは，システム・ライブラリの関数やシステム・コールを発行する際に，ファイルがハード・ディスクにあるか，CD-ROMにあるかなどを意識する必要はありません。カーネルに「このファイルを読む」と指示するだけで良いのです。あとはカーネルがすべて良きに計らってくれます。

カーネルはどこにあるのか
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
前述のようにカーネルは通常のアプリケーションとはかなり違う動作をします。しかし，カーネルといえどもプログラムであることに変わりはありません。そのため，カーネルの実体は，アプリケーションの実行ファイルと同じくファイルの形でファイル・システム上に格納されています。さて，カーネルは一体どこにあるのでしょうか。

ご自分が利用されているLinuxディストリビューションの/bootディレクトリ（またはルート・ディレクトリ）を見てください。そこに「vmlinuz」という名前のファイルがあると思います。これがカーネルの実体ファイルです。

ただし，Linux起動後にこのファイルを実行しようとしても実行できません。既にカーネル・モードでカーネルが動作していますし，カーネル・ファイルは通常の実行ファイルとは格納形式が異なっているためです。カーネルは一般のアプリケーションのように，起動にカーネルの力を借りることはできませんので，カーネル・ローダーという特別なプログラムの力を借りて起動します。

Linuxカーネルバージョン番号
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Linuxカーネルは，「開発版」と「安定版」の2つの系列に分けて開発が進められています。

ネットワークに接続していれば，fingerコマンドで現在のLinux カーネルの最新バージョンを知ることができます。 ::

    % finger -m linux@kernel.org

ネットワークに接続していれば，fingerコマンドで現在公開されているカーネルの最新情報を取得できます。

Linuxの開発にはだれでも平等な立場で参加できますが，意見の取りまとめを行うために，それぞれの主要機能ごとにリーダーが存在します。開発者から送られたパッチ（修正差分）の取り込み（取捨選択）などは，このリーダーの判断により決定します。

Linuxが登場した当初は，Torvalds氏本人がすべてをメンテナンスしていました。しかしLinuxの機能が増えるにつれて開発者の数も増え，同氏がすべてを管理できなくなったため現在の形に落ち着いています。もちろん現在でも，重要な方針を決定する際や，意見がまとまらない場合には，同氏が最終的な決断を行うことに変わりはありません。

プログラムとプロセス
------------------------------------

プロセス管理の重要性
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
前回解説したように，Linuxカーネルはさまざまな機能を提供しています。代表的な機能の一つがプロセス管理（実行管理）です。

Linuxは，複数のプログラムを同時に稼働させられるマルチタスクOSです。また，複数のユーザーが同時にシステムにログインして並行して作業できるマルチユーザーOSでもあります。

マルチユーザーやマルチタスクを実現するには，OS側にさまざまな機能が必要になります。例えば，安全にマルチユーザー環境を提供するために，Linuxのファイルやディレクトリには所有者やアクセス許可属性などの情報が設定されています。ディレクトリやファイルの中を見るには，open（）やread（）といったシステム・コールを発行する必要があります。システム・コールとは，カーネルに仕事を依頼する特別な手続きです。カーネルは，ユーザー権限をチェックして，アクセス権がないときにはエラーを返します（図1）。アクセス権限を適切に管理することで，他のユーザーの重要なファイルをのぞき見たりする行為を禁止できます。 

安全なマルチユーザー環境を提供するために所有者情報などによるアクセス制御機能が提供されています。

また，マルチユーザー/マルチタスクOSでは，複数のユーザーが同時にプログラムを実行したり，1人のユーザーが同時に複数のプログラムを実行することができるため，これらのプログラムを支障なく並列に実行する仕組みが必須になります。

1台のコンピュータで複数のプログラムを安全に動作させるには，何をすべきでしょうか。一番考えなければならないのが，他のプログラムの干渉を防ぐことです。例えば，ユーザーが実行するプログラムは予期できない動作をして他のプログラムやシステムを破壊する可能性があります。Linuxカーネルは，さまざまな工夫でプログラム同士の干渉や，システムの破壊を防止しています。

工夫の一つが，プログラム単位ではなく「プロセス」という単位でプログラムの実行を管理することです。Linuxではユーザーがプログラムを起動すると，その一つひとつが異なるプロセスとして動作します。各プロセスには起動時にユニークな番号（プロセスID）が割り振られ，これを基に管理されます。

プログラムそのものではなく，プログラムの実行状態であるプロセスという概念を利用するのは，同じプログラムを同時に稼働させても，そのそれぞれを区別して管理できるメリットがあるためです。例えば，ディレクトリのファイルを表示するlsコマンドを，違うディレクトリで2つ同時に動かしてみたとします。同じlsコマンドを起動しているので，プログラム単位で管理するとこの2つを区別できません。しかし，プロセス単位で管理すればプロセスIDにより区別できますから，この2つを干渉しないように実行できます。

同じプログラムを同時に起動しても，それぞれが別のプロセスとして管理されるため，干渉が生じません。

プロセスを管理するため，Linuxカーネルではさまざまな情報を記録しています。その一つがプロセスIDですが，ほかにも，どのようなプログラムを起動してできたプロセスであるか，どのユーザーが起動したかなどの情報を記録しています。これらの情報はpsコマンド＊1で確認できます。 ::

    % ps aux
    USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root          1  0.1  0.0 119668  5692 ?        Ss   23:33   0:01 /sbin/init auto noprompt
    rtkit      1320  0.0  0.0 183544  3128 ?        SNsl 23:33   0:00 /usr/lib/rtkit/rtkit-daemon
    root       1360  0.0  0.0 230304  6416 ?        Sl   23:33   0:00 lightdm --session-child 12 19
    masato     1481  0.0  0.0  45360  4508 ?        Ss   23:33   0:00 /lib/systemd/systemd --user
    masato     1873  0.0  0.0 186956  4552 ?        Sl   23:33   0:00 /usr/lib/gvfs/gvfsd-metadata
    実行しているユーザー、プロセスID　                                  コマンド名

メモリ管理の重要性
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
プログラム同士の干渉を避けるには，プロセスを区別するだけでは十分ではありません。プログラム自身やデータを記録するメモリー領域も，プロセスごとにきちんと区別して管理する必要があります。

最近のコンピュータでは，一般にプログラムはハード・ディスクに保存されています。しかし，ディスクに記録したままではプログラムは実行できません＊2。プロセッサは，主メモリーからプログラムを読み込んで実行するように作られているからです。そこでプログラムを実行する際は，プログラムはハード・ディスクから主メモリーに読み出されます。

主メモリーに格納されたプログラムは，順次プロセッサにより読み出されて実行されます。実行されたプログラム（つまりプロセス）は，データをメモリーやファイルから読み出したり，逆に書き込んだりしながら処理を進めます。

ところが，各プロセスが使用するメモリー領域がきちんと区別されていないとどうなるでしょうか。他のプロセスが使用するはずのデータを書き換えてしまったり，プログラム自身が書き換えられるといった危険性が生じてしまいます。このような環境下では，プロセスの正常な動作は期待できません。つまり，各プロセスが使用するメモリー領域も区別する必要があるのです。

プロセスごとに使用するメモリー領域を分ける方法にはいくつかありますが，Linuxでは，プロセスごとに「仮想メモリー空間」（または仮想アドレス空間）を割り当てることでメモリーの干渉を防止しています。プロセスごとにメモリー空間を用意することにより，どのアドレスにアクセスしても，他のプロセスのメモリーを見たり書き換えたりできないようになっています。

Linuxカーネルは，システムに搭載される実際のメモリー（物理メモリー）を「ページ」と呼ばれる小さなブロック単位で管理します。プロセスには必要なメモリー量に応じて複数のページが割り当てられますが，この際，ページの集合に独立したアドレス体系を割り振ります。これが仮想メモリー・アドレスです。プロセスに，この仮想メモリー・アドレスだけを使わせるようにすれば，他のプロセスと干渉せずにメモリーを利用できます。

**図**

プロセスごとに異なる仮想メモリー空間を割り当てることで，干渉やセキュリティ上の問題を防いでいます。

仮想メモリーを利用してアクセスする場合，仮想メモリー・アドレスと物理メモリー・アドレスを変換する必要がありますので，若干のパフォーマンス低下が生じます。最近のプロセッサにはアドレス変換を高速に行うためのキャッシュ機構を搭載するなど，パフォーマンス低下ができるだけ生じない工夫が施されています。

プロセス実行の流れ
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
実際にプログラムを実行する仕組みは，やや複雑です。

皆さんがプログラム実行と聞いて思い浮かべるのは，コマンド・ラインでコマンド名を入力するシーンだと思います。例示した図中でもlsコマンドやpsコマンドをコマンド・ラインから起動していました。しかし，Linuxのコマンド・ラインは，カーネルがプログラム実行用に用意したものではなく，シェルというただのプログラムが提供しているものです＊3。それでは，シェルはどのようにプログラムを実行しているのでしょうか。

先ほど，プロセスはカーネルが管理すると説明しました。プロセスの生成もカーネルの仕事です。前回説明した通り，カーネルに仕事を依頼するには「システム・コール」という特別な手続きを呼び出さねばなりません。プログラムを実行してプロセスを生成する場合も，システム・コールを利用します。利用するのは，fork（）やexec（）といったシステム・コールです。同様に実行中のプロセスを終了させる場合もシステム・コールを利用します。利用するのは，exit（）やwait（）といったシステム・コールです。

プロセスの生成から終了までの流れ（ライフ・サイクル）を図示するとのようになります。

**図**

プロセスを生成したり終了させるのはカーネルの仕事です。そのためシステム・コールを通じて作業を依頼します。

親となるプロセス（例えばbash）が fork（）システム・コールを発行して自分の複製を作成します。作成された複製は，exec（）システム・コールを発行して，自分自身を新しいプログラム（例えばls）に置き換えます。そして処理を行ったあと，exit（）システム・コールで自分自身を終了します。

このとき親プロセス（例えばbash）は，wait（）システム・コールで子プロセス（例えばls）の終了を待ちます。待機するのは，子プロセスが終了した際には親プロセスがいくつかの後始末を行わねばならないからです。

以下では，これらのシステム・コールがどんなことをしているのか，それぞれ見ていきます。

**実行は複製から始まる**

プログラムを実行（プロセスを生成）するときには，fork（）システム・コールを発行します。

fork（）は，呼び出し元のプロセスの複製プロセスを生成するシステム・コールです。元のプロセスを親プロセス，複製したプロセスを子プロセスと呼びます。fork（）で生成した子プロセスには，親プロセスのあらゆる情報がコピーされます。プロセスが使用するメモリーの内容やファイルの情報，プロセスが実行している命令の位置にいたるまで親プロセスと同一になります。ただし，プロセスIDについては異なるものが割り振られます。

なお，fork（）の処理にはデータのコピーが多量に必要であるため非常に時間がかかる「重い」処理になっています。Linuxではこの処理を軽減するための仕組みを用意しています（別掲記事「コピー・オン・ライトでプロセス生成時間を短縮」を参照）。

しかし，なぜプロセスを直接生成するのではなく，複製から始めるのでしょうか。

これは，環境変数の継承や，パイプを使ったプロセス間通信機能を簡単に実現できるためです。例えば，シェルからviエディタを起動してすぐに文字入力できるのは，viがシェルから標準入力などの環境を受け継いでいるからにほかなりません。なお，Linuxに限らず，UNIX系OSでは全般にプロセス生成にfork（）を利用します。

fork（）システム・コールによるプロセス複製（子プロセス生成）が正常に終わると，親プロセスも子プロセスも，fork（）システム・コールの後に続く命令から実行を再開します。このとき親プロセスには，fork（）システム・コールの戻り値として，子プロセスのプロセスIDが渡されます。この情報を記録しておくことで，プロセス間の親子関係が把握できます。

一方，子プロセスの側には0が渡されます。つまり，この戻り値を調べれば，自分が親プロセスか子プロセスかが分かるわけです。これにより，子プロセスの場合にだけ特別な処理を実行することができます。例えば，子プロセスから別のプログラムを実行することができるわけです。実際，シェルがプログラムを実行する場合は，一度シェル自身の子プロセスを作成し，その子プロセスがプログラムを実行する手順を踏みます。

子プロセスから，プログラムを実行するにはexec（）システム・コールを利用します。これは，自分自身を新しいプログラムで置き換えて実行するシステム・コールです。exec（）システム・コールでは，現在のプロセスの仮想メモリー空間を解放し，もう一度新たに作り直して，指定したプログラムをこの空間に割り当てて実行します。このとき入れ替わるのはメモリー空間だけで，親から引き継いで利用しているファイルの情報や環境変数などはそのままです。

**図**

新しい仮想メモリー空間を作成し，プログラムをそのメモリーに読み込んで実行します。

さて，ここまでの説明で疑問を感じた方はいませんでしょうか。そう，fork（）システム・コールによりプロセスを生成する場合，複製元となるプロセスが必要です。ならば一番初めのプロセスはどうやってできたのでしょうか。

実は，一番最初のプロセスだけは，カーネルが自分で生成します。これは「init」というプロセスで，このinitプロセスが，すべてのプロセスの親として動作します。つまり，Linuxのプロセスはinitを根としたツリー状の親子関係を持っています。

**図**

新しく作成したプロセスは，作業が終わったら終了させないといけません。放っておくと，細胞分裂のようにプロセスばかりがどんどん増え続けて，メモリーがいくらあっても足りなくなります。

プロセスを終了させるには，終了したいプロセスからexit（）システム・コールを発行します。これによりカーネルは，このプロセスが使用していたメモリーなどのすべての資源を解放します。しかし，この際，プロセスの親子関係に注意しなければなりません。

というのは，exit（）を発行しただけではプロセスが完全には終了しないからです。exit（）によりプロセスの資源は解放されますが，プロセスの管理情報は削除されません。これを削除するのは親プロセスの仕事です。

親プロセスは，子プロセスの管理情報を削除するため，wait（）システム・コールを発行します。これは子プロセスの終了を待って，終了したら管理情報を削除するシステム・コールです。親プロセスは，子プロセスをfork（）してすぐにwait（）を発行するか，子プロセスからの終了シグナル（後述）を受け取った時点でwait（）を発行します。これにより，子プロセスの管理情報も無事に削除されます。

親プロセスがwait（）システム・コールを発行しない完全に終了できません。

しかし，親プロセスがwait（）を発行してくれないこともあります。その場合，プロセスは終了したのに管理情報だけが残っているという困った状態になります。管理情報が残っているので，psコマンドで調べると実行中のように見えますが，実行してはいませんし，親プロセスがwait（）を発行しない限り管理情報の削除もできません。

このようなやっかいなプロセスは「defunct（死んだ）プロセス」と呼ばれます。また，死んでいるのに動き続けている（ように見える）ことから「Zombie（ゾンビ）プロセス」と呼ばれることもあります。

それでは，defunctプロセスを発生させないために，親プロセスは子プロセスが終了するまで動作し続けないといけないのでしょうか。いいえ，そんなことはありません。実際，シェルからWebサーバーのApacheを起動した後ログアウトしても（つまりシェルを終了しても），Apacheは動作し続けますしdefunctプロセスにもなりません。

これは親プロセス（シェル）の代わりに「init」が子プロセスを引き取って親になっているからです。前項で解説したように，プロセスはinitを一番の親とした木構造になっています。親プロセスを失ったプロセスは，カーネルによってinitに管理情報が登録され，その子プロセスになります。このプロセスの終了処理はinitが担当します。
