====================================
Linux システム関連
====================================

:著者: Masato

概要
====================================
データベースの構築から、インストール、ipの固定までのhow to をまとめていきます。

データベース
====================================

Linux 状態確認
====================================

Top コマンド
------------------------------------
topコマンドで得られる情報は大きく分けて二つある。

* システム全体の負荷
* プロセス、CPU、メモリ、スワップの統計情報

使い方と操作方法
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
通常鵜はtopと打つだけだが、他にも引数がある。 ::
    
    $ top           # CPU使用率順にソート
    $ top -a        # メモリ使用順にソート
    $ top -p [PID]  # 特定のプロセスを監視
    $ top -d1       # 1秒ごとに更新

操作方法

* Shift+o: 表示された特定のキーを押してエンターすると、任意の列でソートできる。
* Shift+p: CPU使用率順にソート
* Shift+m: メモリ使用率順にソート

ヘッダーの見方
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
load average ::

    top - 08:42:47 up 2min,  2 users,  load average: 2.76, 0.76, 0.27
    #     現在時間 サーバーの  ログイン              1分   5分   15分
    #              稼働時間   ユーザー数              間の単位時間あたりの待ちタスク数

uptimeコマンドと同じ結果が返ってくる。

Tasks ::

    Tasks: 110 total,   7 running, 103 sleeping,   0 stopped,   0 zombie
    #      合計タスク数   稼働中       待機中        停止タスク    ゾンビタスク

各状態のタスクの数を見ることが出来る。

CPU ::

    Cpu(s): 77.1%us,  8.4%sy,  0.0%ni,  0.1%id, 14.3%wa,  0.0%hi,  0.2%si,  0.0%st
    #       user      system    nice     idle   I/O wait hardware  software  steal
    #                                                    interrupt interrupt

* ni: niceで実行優先度を変更したプロセスがユーザーモードでCPUを消費した時間
* st: OS仮想化利用時に他の仮想CPUの計算で待たされた時間

sarのようにCPUの利用時間の割合をプロセスの種類ごとに見ることが出来る。
1を押すと、CPUごとの情報が見れる。

Memory/Swap ::

    Mem:  15144564k total,  1178112k used, 13966452k free,    28300k buffers
    Swap:        0k total,        0k used,        0k free,   289928k cached

* buffers: mallocなどでバッファとして利用されているメモリ量
* cached : キャッシュとして利用されているメモリ量（ファイルシステムのキャッシュ）

物理メモリとスワップ領域の使用状況が見れる。freeコマンドでも同じ結果となる。

プロセス一覧 

======= =========== =========== =========== =========== ======= =========== ============== ================
PR       NI          VIRT          RES      SHR          S           %CPU     %MEM            TIME+
======= =========== =========== =========== =========== ======= =========== ============== ================
優先度  相対優先度  仮想メモリ  物理メモリ  共有メモリ  状態    CPU使用率   メモリ使用率    実行時間
======= =========== =========== =========== =========== ======= =========== ============== ================

* NI    : Nice value 相対優先度。0が基準で、負だと優先度が高く、正だと優先度が低い。
* VIRT  : Virtual Image 確保された仮想メモリ全て。スワップしたメモリを含む。
* RES   : Resident size スワップしていない、使用した物理メモリのサイズ
* SHR   : Shared Mem size 他のプロセスと共有される可能性のあるメモリのサイズ
* S     : Process Status 以下のいずれかの状態であるかを示している。

    - D :割り込み不能
    - R : 実行中
    - S : スリープ中
    - T :停止中
    - Z :ゾンビプロセス

Linux バージョン確認
====================================

Cent OS
------------------------------------
Cent OSのバージョン確認::

    $ cat /etc/redhat-releace
    CentOS release 6.8 (Final)

アーキテクチャを確認する。
------------------------------------
OSのバージョン確認コマンド::

    $ arch
    X86_64 <- 64bitの場合
    i686   <- 32bitの場合
    $ uname -a

FTPコマンドでファイル転送
====================================
FTPコマンドは、ホスト名とポート番号を指定して起動します。すると、ユーザ名とパスワードを聞いてくるので入力します。ユーザ認証がOKな場合は各種FTPコマンドが使えます。

================ ====================================================
fptコマンド         機能
================ ====================================================
ftp                 FTPを起動する。
ls                  リモートのファイルの一覧を表示
pwd                 リモートのカレントディレクトリを表示
cd                  リモートのカレント作業ディレクトリを表示
mkdir               リモートのディレクトリを作成
!ls                 ローカルのファイルの一覧を表示
!pwd                ローカルのカレントディレクトリを表示
!cd                 ローカルのカレント作業ディレクトリを移動
get                 ファイルをダウンロード
mget                複数のファイルをダウンロード
put                 ファイルをアップロード
mput                複数のファイルをアップロード
passive             Passiveモードの切り替え
bin /binary         バイナリ転送モードに切り替え
asc /ascii          ASCII転送モードに切り替え
bye /exit /quit     FTPコマンド終了

================ ====================================================

Ubuntuにpukiwikiインストール
====================================

Apach2.4 & PHP インストール
------------------------------------
普通にapt-getする。::

    $ sudo apt-get install apache2
    $ sudo apt-get install php

/var/www/htmlがデフォルトのパブリックフォルダとなっている。apt-getでインストール後は自動的にサーバプロセスが起動する。ブラウザで、::

    http://[サーバー名]/
    http://localhost/index.html

へアクセスし、Apacheのデフォルトページが表示されればOK

PukiWiki1.5.0を設置
------------------------------------
utf8版のPukiWikiを使う。WikiのURLは、http://[サーバー名]/wiki とする。zipファイルなので、unzipする。::

    $ sudo apt-get install unzip
    $ cd /var/www/html/
    $ sudo unzip pukiwiki-1_5_0_utf8.zip
    $ sudo mv pukiwiki-1_5_0_utf8 wiki

Wikiの実効権限をサーバプロセスと同じ、www-dataにする。::

    $ chwon -R www-data.www-data /var/www/html/wiki

これで http://[サーバ名]/wiki にアクセスし、Pukiwikiのデフォルトページが表示される。

http://qiita.com/tuneyukkie/items/e7565fb0856e6a9f517d


Linux ファイルシステム
====================================

/proc
------------------------------------

プロセスやメモリなどのLinuxシステム上のリソース関連情報をあたかもファイルであるかのように配置した
仮想的なファイルシステム、ファイルを読もうとしたときにOSが動的に生成する
大体が読み取り可能だが書き込み可能のものもあって(代表的なものは/proc/sys)
そのファイルを利用すればカーネルのパラメータを変更できる

/procの分類
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
大きくわけて/proc内にはプロセスIDの数字が書かれたディレクトリとLinuxのカーネル内部情報(cpu関連、メモリ関連等)があるpsやunameなどのコマンドが情報を出力する際に直接参照されている。
各ファイルはcatなどで参照できる(/proc/kcoreはメモリのイメージでバイナリなので止めた方がいい)

Linuxのカーネル内部情報
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

=========== ==============================================================================
apm          APMの情報
acpi         ACPI(パソコンの電源管理)の情報
bus          バスの情報を含むディレクトリ
cmdline      カーネルのブートパラメータ
cpuinfo      CPU情報
devices      使用可能なブロック/キャラクタデバイス
dma          DMAチャネル情報
filesystems  サポートするファイルシステム
interrupts   割り込み情報
ioports      I/Oポート情報
iomem        マシンのメモリ使用状況
irq          割り込み情報
kcore        物理メモリのイメージ
kmsg         カーネルのメッセージ
loadavg      負荷情報
locks        カーネル・ロック情報
meminfo      メモリ情報
misc         雑多な情報
modules      ロードされたモジュールの一覧情報
mounts       マウントされたファイルシステムの一覧
net          ネットワークに関する設定を含むディレクトリ
pci          PCIデバイスのリスト
partitions   システムが認識したパーティション情報
scsi         SCSIデバイスの情報を含むディレクトリ
self         カレントプロセスへのシンボリックリンクを含むディレクトリ
stat         カーネル全体の統計情報
slabinfo     スラブキャッシュの状態
swaps        スワップの利用状況
sys          ネットワークやファイル・アクセスなどの設定を含むディレクトリ
uptime       システムの駆動時間
version      Linuxカーネルのバージョン
=========== ==============================================================================

各プロセスIDが書かれたディレクトリ以下
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
=========== ==============================================================================
cmdline     コマンドライン引数
environ     環境変数の値
fd          全てのファイルディスクリプタを含んだディレクトリ
mem         プロセスが保持するメモリ
stat        プロセスの状態
status      statの表示の可読性を高めたもの
cwd         プロセスの現在の作業ディレクトリへのリンク
exe         このプロセスの実行形式へのリンク
maps        メモリマップ
root        該当プロセスへのルートディレクトリへのリンク
statm       プロセスのメモリ状態
=========== ==============================================================================

サーバー管理
====================================

ログイン回避
------------------------------------
アカウントがない状態で、ログインしなければならない場合の対処法について記す。コンソールアクセスが可能で再起動してもいいのであれば、
シングルユーザーモードでブートすればよい。Crtl-Alt-Deleteキーを押した後は単にPOST(Power On Self Test:電源投入時や再起動時に自動的に行われるメモリなどのテスト)が実行されるのを待ち、
カーネルのブート時に **single** というパラメータを渡す。例えば、LILOプロンプトの場合は、::

    LILO: linux singel

でrootのシェルを起動出来るが、RedHatでは使えないときがある。その時は、::

    LIL: linux init=/bin/bash
    # mount -o remount,rw /

とし、起動する。この状態ではネットワークはダウンしており、通常のデーモンは全く起動していないので、パスワードの再設定や1つ2つのファイルに手を加える程度である。
得に、Ctrl-Dや **exit** と入力しない。::
    
    # mount -o remount,ro /

をする必要がある。というのも、initが起動していないため、システムを安全に停止するためにあるプロセスがない。よって読み込み専用でシャットダウンをする。
ブートパラメータは調べるとよりおもしろいので、後で調べる。例えば、::
    
    LILO: linux single init=/bin/bash rw

と表現することも出来る。

Amazon Linux
====================================
cuda構築するときの参考 http://qiita.com/pyr_revs/items/e1545e6f464b712517ed

Caffeの構築
------------------------------------
https://gist.github.com/rezoo/a1c8d1459b222fc5658f

yumで入れられるもの
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
できる限りyumで入れる。 ::

    $ sudo yum install protobuf-devel snappy-devel

Atlasインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Numpyで演算に使用されるatlasをインストールする。 ::

    $ sudo yum install atlas-sse3-devel.x86_64

環境変数ATLAS,BLAS,LAPACKを設定する。 $HOME/.bashrcに記述する。 ::

    export ATLAS=/usr/lib64/atlas-sse3/libatlas.a
    export BLAS=/usr/lib64/atlas-sse3/libcblas.a
    export LAPACK=/usr/lib64/atlas-sse3/liblapack.a

Boostインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
caffeのPythonラッパはboost-pythonというライブラリで開発されている。 
そのため、Boostライブラリが必要になる。 BoostはCaffeでも必要なので、boost-pythonだけでなく全部入れる。 ::

    $ sudo yum install boost-devel.x86_64


Anacondaインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AnacondaはPythonにデータ解析等で使用するライブラリがContinuum Analytics社があらかた準備されているものです。後から自分で入れるものが減るので、使えるならこちらを使う。
https://www.continuum.io/downloads 
インストール後に$HOME/.bashrcの末尾に ::

    xport PATH=$HOME/anaconda/bin:$PATH
    export LD_LIBRARY_PATH=$HOME/anaconda/lib:$LD_LIBRARY_PATH

を記述する。anacondaが勝手にやるが、もし出来てなかったら自分でやる。
opencvもcondaで入れることが出きるので、こちらからもやる。 ::

    $ conda update opencv

また、condaからpipをインストールすることで、pip経由でインストールできる。 ::

    $ conda install pip

Protocol Bufferをインストールする。 ::

    $ pip install protobuf

OpenCVインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
opencvはcmakeでビルドするため、yumでインストールする。 ::

    $ sudo yum instal cmake

Linux版のアーカイブを公式からダウンロードする。解凍したディレクトリで以下のコマンドを実行していく。 
http://opencv.org/downloads.html ::

    $ mkdir build
    $ cd build/
    $ cmake ..
    $ make
    $ sudo make install

glogインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
glogのアーカイブをダウンロードし、ビルドする。 https://code.google.com/p/google-glog/ ::

    $ ./configure
    $ make 
    $ make check
    $ sudo make install

gflagsインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
gflagsのアーカイブをダウンロードし、ビルドする。https://code.google.com/p/gflags/ ::

    $ mkdir build
    $ cd build/
    $ CXXFLAGS="-fPIC" cmake ..
    $ make
    $ sudo make install

-fPICをつけておかないと、caffeにリンクすることが出来ないので注意。

leveldbインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
leveldbのアーカイブをダウンロードし、ビルドする。 https://code.google.com/p/leveldb/ ::

    $ make
    $ make check
    $ cd ..
    $ sudo mv leveldb-1.15.0 /opt/leveldb
    $ sudo cp -r leveldb/include/leveldb /usr/local/include

これでダメだったので、その時の対処について述べる。 ::
    
    -fPICオプション付きでコンパイルするように言われたので、
    MakefileのCFLAGSをいじる。
    CFLAGS = -c -I ...... $(OPT) -fPIC

これで再度makeする。また、ライブラリについても共有する必要があるので、makeした後にできる

hdf5インストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
hdf5のアーカイブをダウンロードし、ビルドする。
https://support.hdfgroup.org/HDF5/release/obtainsrc.html ::

    $ ./configure --prefix=/usr/local/hdf5 --enable-fortran --enable-cxx
    $ make 
    $ make check
    $ sudo make install
    $ sudo make check-install

lmdbインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
gitoriousのリポジトリからソースコードを取得し、ビルド、インストールする。 https://gitorious.org/mdb/mdb ::

    $ git clone https://gitorious.org/mdb/mdb.git
    $ cd mdb/libraries/liblmdb/
    $ make -j8
    $ make -j8 test
    $ sudo mkdir /usr/local/man
    $ sudo make install

Caffeインストール
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
githubからcaffeのコードを取得し、ビルドする。https://github.com/BVLC/caffe.git ::

    $ git clone https://github.com/BVLC/caffe.git
    $ cd caffe
    $ cp Makefile.config.example Makefile.config

Makefile.configでpython、atlas、GPU、CPU設定をする。 ::

    $ make all
    $ make test
    $ make runtest

runtestをするために、環境変数の設定が必要である。(.bashrcに追記) ::
    
    export LD_LIBRARY_PATH=/usr/local/lib/:$LD_LIBRARY_PATH
    export LD_LIBRARY_PATH=/opt/leveldb:$LD_LIBRARY_PATH
    export LD_LIBRARY_PATH=/usr/local/hdf5/lib:$LD_LIBRARY_PATH

make runtestをして、エラーがでなければ、正常にビルドが完了している。次にpython用のcaffeパッケージをビルドする。
そのために、 ::

    $ make pycaffe

をし、PYTHONPATH環境変数にcaffeのpythonディレクトリを塚することも必要。
pythonを起動し、 ::

    >>> import caffe

でエラーがでなければ大丈夫。Protocol buffer関係のエラー出た場合は多分protobufパッケージをインストールしていないだけなのでインストールする。


linux カーネル
====================================

linux カーネルの機能
------------------------------------
Linuxは，フィンランド・ヘルシンキ大学の学生だったLinus Torvalds氏が，i386プロセッサの勉強のために作成したオペレーティング・システム（OS）です。1991年に誕生しました。当初はネットワーク機能すらない貧弱なOSでしたが，いまや企業の基幹業務にも使われる実用的なOSとして成長しています。これは，Torvalds氏をはじめとした多くの開発者が，Linuxの改良に取り組んできた結果です。

Linuxが誕生した1990年代は，ネットワーク機能を標準装備したWindowsシステムの登場や商用ISPのサービス開始により，インターネットが爆発的に普及した時代です。それと同時に一般家庭にもパソコンが浸透し，広く利用されるようになった時代でもありました。

その一方で，コンピュータの仕組みや動作を理解する人の割合は年々減ってきているように思います。LinuxやWindowsなどの現代的なOSは，ハードウエアやOSの構造を知らなくても簡単にアプリケーションの作成ができる環境を提供してくれます。GUIも充実し，ユーザーにとっては利用しやすい環境になっています。

この状況は自動車に似ています。自動車が登場した頃は，自動車の構造をよく知っている人しか利用できませんでしたが，現在では自動車の内部構造を深く知らなくても，簡単に運転できる機構が用意されています。

しかし，自動車の性能を余すところなく利用するには，内部構造のきちんとした理解が必要です。同様に，コンピュータの性能を発揮させるには，利用者に対して隠ぺいされている部分の理解が必要です。コンピュータの仕組みや動作を理解することにより，性能上

Linuxとは何か，こう聞かれたときに私は「コンピュータのオペレーティング・システム（OS）の一つです」と答えます。では，OSとはいったいどのようなものなのでしょうか。OSを一言でいうと「ユーザー・アプリケーションに実行環境を提供するソフトウエア」になります。しかし，これでは簡潔過ぎて何だか分かりませんので，もう少し具体的に見てみましょう。

例えば，コンピュータにログインする場合を考えてください。ログイン時には，キーボードからユーザーIDを入力します。入力した文字は画面に表示されます。このような動作が可能なのは，当然ですがログイン用のソフトウエアが，これらの処理を行うようにプログラムされているからです。

ところが，実際には，ログイン用ソフトウエアは，キーボードの入力信号を判定したり，画面へのドット出力を制御するようにはプログラムされていません。キーボード入出力や画面出力のような基本的な処理を個々のソフトウエアで実装するのは，無駄が多く手間もかかるからです。例えば，キーボードやビデオ・カードなどの種類によってプログラムを書き分けねばなりません。

代わりにこれらのソフトウエアには，「入力デバイスから文字を受け取る」や「出力デバイスに文字を出力する」という抽象的命令が記述されています。これらの命令を受け取って，実際にキーボードの入力を制御したり，画面に表示したりするのがOSの仕事です。

ハードウエアの制御をOSが肩代りすることで，アプリケーションの作成が容易になります。

またOSは，指示に従ってディスクからソフトウエアをメモリーに読み込んで実行させるといった補助的な仕事も行います。これにより，プログラマはソフトウエア作成時にこのような部分まで作り込む必要がなくなります。

コンピュータの登場初期は，各ソフトウエアごとに独自にハードウエアの制御をしていました。しかし，これでは効率が悪いため，OSという共通インフラが整備されたのです。OSの登場により，アプリケーションの開発が楽になると同時に，ハードウエアの細かな違いをOSが吸収し，同じプログラムをさまざまなコンピュータ上で実行できるようになりました。

OSの中心であるカーネル
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
OSの中でも，特に中心となるものが「カーネル（kernel）」です。カーネルというのは英語で「核」という意味で，文字通りOSの一番重要な部分を指します。なお，OSは，広義ではカーネルや基本ライブラリ・基本ツールを含む総称として用いられますが，狭義にはカーネルのみを指します。カーネルにはOSのエッセンスが詰まっているのです。先程のように，アプリケーションからの命令を受け取ってハードウエアを制御するのは，すべてこのカーネルの仕事です。

このカーネルの機能の違いがOSの性質を表すといっても過言ではありません。例えば，MS-DOSで利用されているカーネルは，アプリケーションが直接ハードウエアを制御することを許可しています。柔軟な制御が可能ですが，アプリケーションのバグがシステム破壊をもたらす可能性があります。これに対しLinuxでは，原則としてカーネルを通じてのみハードウエアを制御できます。危険な操作はカーネルでブロックできるため，システムの安全性は高いと言えます。

現代的なOSのカーネルは一般的に，次のような6つの主要機能を備えています。カーネルがこれらの機能を必要に応じて提供することで，高度な機能を持つアプリケーションが安全に稼働できるのです。

======================= =============================================================================================================================================
カーネルが提供する機能      解説
======================= =============================================================================================================================================
プロセス管理            システム上で動作するアプリケーション・プログラムの実行を制御する。ユーザーがアプリケーションを起動すると、その1つひとつはプロセスとなり
                        カーネルにより管理される。書くプロセスごとに独自の実行環境を割り当てて、マルチタスクを実現する。
空間管理                システムに搭載しているメモリーを管理する。プロセッサがもつ機能を利用して、プロセスごとに仮想的なメモリー空間(VM)を作り、そのメモリ割り当てを
                        行う。メモリーが足りなくなると、その一部をディスクに退避させたりし、メモリーを効率的に利用できるようにする。
時間管理                システム実行時の時間を管理する。特定の時間が経過したら、処理を行う時限処理を行ったり、システムの現在時刻を計算したりして、時間の管理をする。
割り込み管理            ハードウェアからの信号を受け取ってプログラムを起動する割り込みの制御をする。キーボードの入力やディスクの入出力、ネットワークパケットの送受信
                        など、コンピュータに接続されているハードウェアの多くは、割り込み機能を利用して、データの入出力を通史する。割り込み管理では各種割り込みに
                        応じた制御をする。
ファイル・システム      アプリケーションやデータなどはファイルとして保存する。カーネルはこのファイルを格納するためのファイル・システムという論理的なデータと、
                        ディスクに書き込むことが出来るディスク・ブロックを対応付ける役割を持っている。
ネットワーク            インターネット・プロトコル(IP)を始めとした、様々なプロトコルによるネットワーク通信機能を提供する。
======================= =============================================================================================================================================

カーネルは，コンピュータが起動したときに一番最初に動作するプログラムです。カーネルは，コンピュータのさまざまなハードウエアを初期化し，アプリケーションの動作環境を整えます。しかしそのあとは，カーネルは何もしない状態になります。なぜなら，カーネルはアプリケーションが動作するための補助的な仕事をしますので，自発的に動作をする必要がほとんどないからです。後述するアプリケーションからのシステム・コールやハードウエアからの割り込み信号などにより動作する，イベント駆動型のソフトウエアなのです。

これらカーネル一般の特徴に加えて，Linuxカーネルにはさまざまな特徴があります。オープンソースであることや対応プラットフォームが多いなど，他のOSのカーネルにはないLinux独特のものもあります。主な特徴を次に挙げました。

============================= =======================================================================================================================================
特徴                             解説
============================= =======================================================================================================================================
マルチタスクに対応              マルチタスクとは同時に複数のプログラムを動作させる機能である。カーネルには、複数のプログラムが競合せずに動作する仕組みがある。
マルチユーザーに対応            複数のユーザーが同時にシステムを利用できす。セキュリティを確保するために、ユーザーごとにファイルの読み書き権限を設定出来る。
POSIX規格に準拠                 POSIX(Portable Operating System Interface)とは、OSとアプリケーション間の標準インターフェースを定めた規格である。
                                IEEE(アメリカ電気電子学会)が中心となって策定する。OSがPOSIXに準拠することで、他のOSとアプリケーションのソースコードレベルの互換性が
                                取りやすくなっている。
モノリック・カーネルを採用      伝統的なUNIXと同じくモノリシック・カーネルを採用している。モノリスとは一枚岩のことであり、カーネル全体が1つのプログラムを意味する。
モジュールの動的ロードに対応    動的な機能を追加・削除するためのカーネル・モジュール機構を持っている。これにより、再起動せずに新しい機能を追加したり、使わない機能
                                を取り外してリソースを有効活用出来る。
オープンソースである            LinuxはGNU GPL(General Public License)というオープンソース・ライセンスを基に配布されている。
                                ソースコードは誰でも見ることができ、改善したものを自由に再配布できる。
多くのアーキテクチャに対応      数多くのアーキテクチャに対応している。20種類以上に対応している。
開発速度が早い                  開発がバザール方式で行われてるため、進化の速度が早いのが特徴である。開発メーリングリストには、たくさんのパッチが投稿される。
============================= =======================================================================================================================================

システムコールの機能
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Linuxでは，アプリケーションはハードウエアを直接制御することはできません。前述した通り，カーネルを通じてハードウエアを制御します。それではアプリケーションは，どのようにしてカーネルに指示を出すのでしょうか。

Linuxカーネルには「システム・コール」とよばれる，アプリケーションから呼び出し可能なプログラム群が用意されています。アプリケーションは，このシステム・コールを呼び出すことでカーネルに指示を出し，カーネルの機能を利用できるのです。

**図**

アプリケーションは，システム・コールを呼び出すことでカーネルの機能を利用できます。

例えば，ファイルを読み書きするには，まずファイルをオープンする必要があります。ファイルは一般にハード・ディスクに収められていますが，アプリケーションからは直接ハード・ディスクにアクセスできません。そこで，openシステム・コールを発行＊2し，カーネルに目的のファイルを使いたい旨を伝えます。するとカーネルは，そのファイルを利用する権限をアプリケーションに与えます。また，LinuxはマルチタスクOSですから，複数のアプリケーションが同時にファイルをオープンしないようにする仕組みも必要です。この仕組みは，flockシステム・コールが提供しています。

システム・コールがない場合には，アプリケーションはファイルが置かれているファイル・システムの違いや，物理デバイスの違い（ハード・ディスクなのか，フロッピ・ディスクなのか，CD-ROMなのか）を意識してアクセスしないといけません。排他制御も十分に行えず，ファイル破壊などの危険も生じます。

システム・コールを用意しておき，こういった処理をカーネル内部で行うことにより，アプリケーションは「ファイルを読む」といった仕事に集中できるわけです。そのほかにも，時刻を知るシステム・コールやネットワーク入出力用のシステム・コールなど，たくさんのシステム・コールが存在し，その数は200を超えます。システム・コールの一覧は/usr/include/asm/unistd.hファイルに記述してあります。

カーネル・モードとユーザー・モード
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
しかし、システム・コールを使わないと，なぜアプリケーションはハードウエアにアクセスできないのでしょうか。

それは，アプリケーションが，通常は「ユーザー・モード」と呼ばれる制限モードで動作しているからです。ユーザー・モードでは，カーネル内部の情報やハードウエアを直接参照することは禁止されています。

これに対し，システム・コールを発行して，カーネル内部のプログラムを実行しているときは，メモリー空間やハードウエアへのアクセスが自由な「カーネル・モード」と呼ばれる特権モードに切り替わります。そして，ハードウエアへのアクセスなど，特権が必要な処理を行った後，システム・コールが終了し，アプリケーションの動作は再び「ユーザー・モード」に戻ります。

**図**

システム・コールを呼び出すと，カーネル・モードに切り替わり，ハードウエアに直接アクセスできるようになります

このように動作モードを分けることにより，ユーザー・モードで実行しているときに重大なミスを犯しても，システム全体に悪影響が及ばないようになっているのです。例えば，アプリケーションでの利用が許可されていないメモリー・アドレスにアクセスしても，カーネルが「Segmentation Fault」というエラーを出してアプリケーションを強制終了できます。このとき，他のアプリケーションには何の影響もありません。

カーネルのこの機能は，最近のプロセッサに備わっている，権限レベルを複数設定する保護機能を利用しています。例えば，x86互換プロセッサは0～3までの4つの権限レベルを持ち，Linuxではカーネルが最高権限のレベル0，アプリケーションは最低権限のレベル3で動作するようになっています。

ハードウェアをファイルで提供
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
カーネルの中で，最もハードウエアに近く，ハードウエアの制御を行う部分がデバイス・ドライバです。デバイス・ドライバはハードウエアを制御すると共に，性質の似たハードウエアをひとまとめに抽象化し，共通の手続きでカーネルやアプリケーションから利用できるようにします。

LinuxなどのUNIX系OSでは，ハードウエアを「キャラクタ・デバイス」と「ブロック・デバイス」の2つに大別して抽象化します。

キャラクタ・デバイスは，データの読み書きを1バイト（1キャラクタ＊3）ずつ順に行うハードウエアを抽象化したものです。デバイス・ドライバではデータの入出力順を変更したりせず，ユーザー・アプリケーションとハードウエアが直接データをやり取りする形になります。最も基本的なデバイスの抽象化形式と言え，ほとんどすべてのデバイスをキャラクタ・デバイスとして取り扱うことができます。Linuxでは，サウンド・カードやシリアル・ポートなどをキャラクタ・デバイスとして利用します。

これに対しブロック・デバイスは，データの読み書きをブロック単位で行うハードウエアを抽象化したものです。ブロック・デバイスの最大の特徴は，カーネル空間内の固定長のバッファ（一時記憶領域）を経由して入出力を行うことです。これにより，デバイス上の不連続な位置に記録されているデータへアクセスする「ランダム・アクセス」に対応しやすくしたり，処理の高速化が実現できます。また，ブロック・デバイス上には，ファイル・システムを構築できるのも特徴の1つです。Linuxでは，ハード・ディスク・ドライブやCD-ROMドライブなどをブロック・デバイスとして利用します。

これらのデバイスは，2種類の番号を付けて管理されます。サウンド・デバイスやIDEデバイスといったデバイスの種類を示すのが「メジャー番号」で，同じメジャー番号のデバイス同士を区別するための番号が「マイナー番号」です。メジャー番号とマイナー番号には，それぞれ0～255までの数値が使用可能です。

UNIX系OSでは，デバイスへの入出力は「デバイス・ファイル」という特殊な形式のファイルを通じて行います。デバイスをファイルとして提供することで，ファイルを扱うのと同じ手順でアプリケーションからデバイスを扱えるメリットがあるからです。

デバイス・ファイルは，原則として/devディレクトリに配置する決まりになっています。図4のように，-lオプション付きでlsコマンドを実行することでデバイス・ファイルの属性を調べられます。ファイル・タイプが「c」になっているものがキャラクタ・デバイス，「b」になっているものがブロック・デバイスです。メジャー番号とマイナー番号も表示されています。

**図**
