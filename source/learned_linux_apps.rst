====================================
Applications on Linux
====================================

:著者: Masato

概要
====================================
Linux上で動かすアプリケーションの使い方、コツについて載せていきます。

shell
====================================

端末出力をコピー
------------------------------------
xselコマンドを使うと内容がクリップボードと共有できる。::

    xsel --clipboard --input
    xsel --clipboard --output

プロンプトの表示を変更するには
------------------------------------
ログインして以下のように表示されるのがプロンプトです。::

    [swallow@arch~]$

プロンプトはシェル似よって表示が若干異なるが、bashのプロンプト表示は **$** が一般ユーザー、**#** がスーパーユーザー(root)となる。
この表示の制御はPS1という環境変数によって設定されている。この環境変数PS1の値を変更すれば、オリジナルのプロンプトを表示させることができ、
その設定にはexportコマンドを使用する。

設定値には、以下にような特殊な文字が設定出来る。

======= ============================
\d      日付
\h      ホスト名（ドメイン名なし）
\H      ホスト名（ドメイン名あり）
\s      シェルの名前
\t      時間（24時間制 HH:MM:SS形式)
\T      時間（12時間制 HH:MM:SS形式)
\@      時間（12時間制 HH:MM AM/PM形式)
\u      ユーザ名
\w      カレントディレクトリ
\W      カレントディレクトリのベース名
\!      コマンド履歴番号を表示
\#      コマンドのコマンド番号
\$      rootなら#、それ以外なら$を表示
\\      バックスラッシュ
======= ============================

現在の環境変数PS1の値を表示する。::

    [swallow@arch~]$ echo "$PS1"
    [\u@\h\W]

現在の環境変数PS1の値を表示する。::

    [swallow@arch~]$ export PS1="[\u@\t\w]\$ "
    ↑最後は半角スペースを入れる。

これは再ログインすると設定が元に戻ってしまうので、永続した設定にするには、.bashrcにさっきのものを記述する。

ターミナル上でのショートカット
------------------------------------

一覧
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

=========   ===================================================================================================================================================================================================================
Ctrl + a    カーソルを行頭へ移動する
Ctrl + e    カーソルを行末へ移動する
Ctrl + d    現在の入力行に何か入力されている場合は、カーソルの後ろにある一文字を消去する （Deleteキーと同じ働きをする）別のユーザにログインしている場合は、別のユーザからログアウトする （「exit」コマンドと同じ働きをする）
Ctrl + h    カーソルの前にある一文字を消去する（Backspaceキーと同じ働きをする）
Ctrl + u    現在入力中の行をクリアする
Ctrl + l    ターミナルをクリアする（「clear」コマンドと同じ働きをする）
Ctrl + k    カーソルより後ろにある文字列を切り取る
Ctrl + y    切り取った文字列を貼り付ける
Ctrl + r    コマンドの履歴を表示する
Ctrl + f    →キーを押すのと同じ働きをする
Ctrl + b    ←キーを押すのと同じ働きをする
Ctrl + p    ↑キーを押すのと同じ働きをする
Ctrl + n    ↓キーを押すのと同じ働きをする 
=========   ===================================================================================================================================================================================================================

コピー & ペースト
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
コピーしたい文字列をマウスで選択するとコピーできます。ペーストしたいときは、3ボタンマウスの真ん中のボタンを押すか、「Shift + Insert」キーを押せばペーストできます。


Vim
====================================

viの基本コマンドまとめ
------------------------------------
編集コマンド

=====================   ======== ========= ==========
テキストオブジェクト      変更    削除      コピー
=====================   ======== ========= ==========
1語                     cw       dw         yw     
2語(句読点は入れない)   2cW      2dW        2yW
3語前まで               3cb      3db        3yb
1行                     cc       dd         yy Y
行末まで                c$ C     d$ D       y$
行頭まで                c0       d0         y0
1文字                   r        x X        yl yh
5文字                   5s       5x         5yl
=====================   ======== ========= ==========

移動コマンド

====================== ================
 移動                    コマンド
====================== ================
 次行の一文字目に         \+
 前行の一文字目に         \-
 単語の末尾に             e E
 単語単位で順方向に       w W
 単語単位で逆方向に       b B
 行末まで                 $    
 行頭まで                 0
====================== ================

================================================  =================
移動                                                コマンド
================================================  =================
1画面分順方向にスクロール                           ^F
1画面分逆方向にスクロール                           ^B
1/2画面順方向にスクロール                           ^D
1/2画面逆方向にスクロール                           ^U
1行分順方向にスクロール                             ^E
1行分逆方向にスクロール                             ^Y
カレント行が画面の一番上になるようにスクロール      z[Enter]
カレント行が画面の中央になるようにスクロール        z.
カレント行が画面の一番下になるようにスクロール      z-
画面を書き直す                                      ^L
ホーム(画面の一番上の行)にジャンプ                  H
画面の中央行にジャンプ                              M
画面の最下行にジャンプ                              L
次の行の1文字目にジャンプ                           [Enter]
次の行の1文字目にジャンプ                           \+
前の行の1文字目にジャンプ                           \-
カレント行の空白以外の1文字目に移動                 ^
カレント行のn桁目に移動                             n|
単語の末尾にジャンプ                                e
単語(句読点も単語の一部とする)にジャンプ            E
現在の文の先頭にジャンプ                            (
次の文の先頭にジャンプ                              )
現在の段落の先頭にジャンプ                          {
次の段落の先頭にジャンプ                            }
現在のセクションの先頭にジャンプ                    [[
次のセクションの先頭にジャンプ                      ]]
パターンを順方向に検索                              /pattern
パターンを逆方向に検索                              ?pattern
検索を繰り返す                                      n
反対方向で検索を繰り返す                            N
順方向に検索を繰り返す                              /[Enter]
逆方向に検索を繰り返す                              ?[Enter]
カレント行の次のxに移動                             fx
カレント行の前のxに移動                             Fx
カレント行の次のxの直前に移動                       tx
カレント行の前のxの直前に移動                       Tx
直前の検索コマンドを同じ方向で繰り返す              ;
直前の検索コマンドを反対方向で繰り返す              ,
n行目にジャンプ                                     nG
ファイルの末尾にジャンプ                            G
直前のマークまたは文脈に戻る                        ``
直前のマークを含む行の先頭に戻る                    ''
カレント行の情報を表示                              ^G
================================================  =================

その他
2行連結         J

テキストの作成操作のコマンド

====================================== ==========
編集動作                                コマンド
====================================== ==========
現在位置にテキストを挿入                i
行頭にテキストを挿入                    I
現在位置のうしろにテキストを挿入        a
行末にテキストを追加                    A  
新しい行を下にオープン                  o
新しい行を上にオープン                  O
行を削除してテキストを置換              S
現在文字を新しいテキストで上書き        R
現在行と次行を連結                      J
大文字と小文字を入れ変える              ~
最後の動作を繰り返す                    .
最後の変更を取り消す                    u
行を最初の状態に復元する                U
====================================== ==========

いろいろな編集例

========== ============ =========== ===============
変更        削除        コピー      カーソル位置から
========== ============ =========== ===============
cH          dH          yH          画面の最上行まで
cL          dL          yL          画面の最下行まで
c+          d+          y+          次の行まで
c5|         d5|         y5|         カレント行の5桁目まで
2c)         2d)         2y)         2つあとの文まで
c{          d{          y{          前の段落まで
c/pattern   d/pattern   y/pattern   patternまで
cn          dn          yn          次のpatternまで
cG          dG          yG          ファイルの終わりまで
c13G        d13G        y13G        13行めまで
========== ============ =========== ===============

特定の位置からファイルを編集するには以下のとおりである ::

    $ vim +n file           n行目の位置でfileをオープン
    $ vim + file            最終行の位置でfileをオープン
    $ vim +/pattern file    最初にpatternが見つかった位置でfileをオープン
    $ vim +/"you make" file もし2語以上になるのであれば、囲む

読み出し専用モードで開く ::

    $ vim -R file

バッファの復旧 ::

    $ ex -r
    または
    $ vim -r 

バッファの利用
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
削除した内容は最後の9つまでバッファに保存される。例えば、最後から2番目の削除内容を復元したい場合、 ::

    "2p

とすると、バッファ2の内容がカーソルの後に挿入される。自分が復元したい削除内容がどのバッファに入っているのかわからない場合でも"npを何度もタイプする必要はない。
pのあとに、uと繰り返しコマンド.をタイプすれば、バッファ番号が自動的に繰り上がるからである。よって、次の様に番号付きバッファを順に確認していける。 ::

    "1pu.u.u   ....

こうするとバッファ内容が一つづつ順番にファイルに復元される。つまり、毎回uを押すたびに復元されたテキストが取り除かれ、.を押したときにその次のバッファ内容がファイルに復元される。

名前付きでバッファに保存することができる。名前付きバッファは26(a~z)個あり、名前付きバッファにヤンクするにはヤンクコマンドの前にダブルクォート“とヤンク先のバッファ名の文字をつければいい。 ::

    "dyy        カレント行をバッファdにヤンク
    "a7yy       7行をバッファaにヤンク

名前付きバッファにテキストをロードして別の場所に移動したら、次の用にpかPを使ってテキストを復元する。 ::

    "dP         バッファdの内容をカーソルの前に挿入
    "ap         バッファaの内容をカーソル後に挿入

テキストを削除して、名前付きバッファに記憶する作業も上記とほとんど同じ感じである。 ::

    "a5dd       5行削除してバッファaに入れる

バッファ名を大文字で指定すると、ヤンクしたり削除したテキストがそのバッファの現在の内容の末尾に追加される。 ::

    "zd)        カーソル位置から現在の文の末尾まで削除して、バッファzに保存
    2)          2つあとの文にジャンプ
    "Zy)        その次の文をバッファzに追加

位置のマーク
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
viのセッション中には、ファイル中に見えないしおりをはさめる。コマンドモードで以下のものを実行する。

========== ==========================================================
コマンド    意味
========== ==========================================================
mx            現在の位置にxというマークをつける
'x            シングルクォートxでマークした行の1行めにカーソルを移動
`x            バッククォートxでマークしていた文字にカーソルを移動
``            移動して直前のマークまたは文脈の位置に戻る
''            著事前のマークまたは文脈のある行の先頭に戻る
========== ==========================================================

exコマンド
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

========= ===== ================
delete      d   行の削除
move        m   行移動
copy        co  行のコピー
copy        t   行のコピー(同じ)
========= ===== ================

使い方を以下に示す。 ::
    
    :3,18d              3~18行目を削除
    :160,224m23         160~224行目を23行目の後に移動
    :23,29co100         23~29行目を100行目の後にコピー

行に関する情報が知りたい場合、 ::

    :=                  行の総数を表示
    :.=                 カレント行の行番号を表示
    :/pattern/=         patternにマッチする最初の行の番号を表示

ドット.はカレント行、$はファイルの最終行をそれぞれ表す。また、%はファイルの全ての行という意味で、1,$という組み合わせと同じである。 ::

    :.,$d               カレント行からファイルの最終行まで削除
    :20,.m$             20行目からカレント行までをファイルの最後に移動
    :%d                 ファイル中のすべての行を削除
    :%t$                全ての行をコピーして、ファイルの終わりに追加

+,-により、カレント行相対アドレスも指定できる。 ::

    :.,.+20d            カレント行から次の20行まで削除
    :226,$m.-2          226行目からファイルの終わりまでを、カレント行の2行前に移動
    :.,+20#             カレント行から20行先の行までの行番号を表示

検索パターンについて示す。 ::

    :/pattern/d                 次にpatternが出現する行を削除
    :/pattern/+d                次にpatternが出現する行の下の行を削除
    :/pattern1/,/pattern2/d     pattern1を含む最初の行からpattern2を含む最初の行までを削除
    :.,/pattern3/m23            カレント行からpatternを含む最初の行までのテキストを削除して、23行目の後ろに挿入する。

書き込みと読み込み ::

    :230,$w newfile             230行からファイルまでをnewfileにセーブ
    :1,10w newfile              1から10行めまでをファイルにセーブ
    :340,$w >> newfile          リダイレクトで追加でファイルに書き込み
    :read filename              別のファイルの読み込み :r で短縮系
    :r /home/tim/data           カレント行に読み込み
    :185r /home/tim/data        185行目あとに読み込み
    :/pattern/r /home/data      読み込んだファイルを現在のファイルのpatternを含む行の後に入れる。
    :wq                         ファイルを書き込んで終了する。ファイルが変更されなかった時でも無条件に書き込みが実行される。
    :x                          ファイルを書き込んで終了する。ファイルが変更された場合のみ書き込みが実行される。

:x,:wqの違いはソースコードを変更してmakeを使用するときに重要になる。makeはファイルの修正日時に基づいて動作するためである。

一括置換
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
置換コマンドの構文は次のとおりである。 ::
    
    :s/old/new

この構文は、カレント行で最初に出現するoldというパターンをnewに置きかえる。スラッシュはコマンドの各部分を区切る印である。また、 ::

    :s/old/new/g

これは、最初に出現するパターンだけでなく、全てのoldをnewに変更する。例えば、 ::

    :50,100s/old/new/g          50~100行目に出現する全てのoldをnewnに変更する。
    :1,$s/old/new/g             ファイル全体で全てのoldをnewに変更する。
    :%s/old/new/g               上と同じ。
    :1,30s/his/the/gc           c(確認)をつけることで、確認しながら置換出来る。

確認をしながらやる場合は、置換したいときはyとエンターが必要である。変更したくなければ、エンターのみ押せば変更されず、次の候補にいく。

文脈依存置換
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
一番簡単な一括置換は、1語を別の語に置き換える作業である。例えば、 ::

    :%s/editer/editor/g

これでファイル内のすべてのediterがeditorに置換される。文脈依存置換はパターンにより複雑な置換を行うことが出来る。 ::

    :g/pattern/s/old/new/g

先頭のgは、ファイルのすべての行をコマンドの対象にするという意味である。patternは置換を実行したい行を示す。
exは、patternを含んだ行に出現するoldをnewに指定した文字列に置換する。(s)
例えば、SGMLの擬似命令<keycap>を含む行に出現するEscだけをESCに変えるには、次のコマンドを実行すればいい。 ::

    :g/<keycap>/s/Esc/ESC/g

　なお、行を見つけるのに使用するパターンと変更するパターンが同じ場合には、2度指定する必要はない。次のコマンドは ::

    :g/string/s//new/g

stringを含んだ行を見つけて、そのstringをnewに変えるという意味になる。従って、次のコマンドは結果が同じになる。 ::

    :g/editer//editor/g
    :%s/editer/editor/g

パターンマッチング
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
vimでは正規表現による処理も可能である。正規表現は、exコマンドの:gや:sだけでなく、vimコマンドの/と?にも使うことが出来る。

========== ===========================================================================================================
pattern     意味
========== ===========================================================================================================
.           改行を除く任意の1文字にマッチする。空白も文字として扱われる点に注意。
            例えば、p.pなら、pep, pip, pcpなどの文字列にマッチ

\*          これの直前にある1文字の0個以上の並びにマッチ。
            例えばbugs*は、bugs(sが1個), bug(sが0個)にマッチする。
            *の前の文字は正規表現で指定された文字でも良い。例えば、.は任意の文字にを表すので、
            .*は「任意の文字の0個以上の並びにマッチする。」
            具体例を上げると、:s/End.*/End/はEndのあとにあるすべての文字を乗り除くコマンドになる。

^           正規表現の先頭でこれが使われた場合に、これの直後にある正規表現が行の先頭に出現しなければならないという
            意味を表す。例えば、^Partは行の先頭にあるPartにマッチし、^...ならば、行の先頭にある3文字を表す。
            正規表現の先頭に指定されていなければ、^は文字通りの意味になる。

$           正規表現の最後でこれが使われた場合には、これの直前にある正規表現が行の最後に出現しなkればならないことを
            意味する。例えば、here:$は、行末に出現するhere:のみにマッチする。正規表現の最後に指定されていなければ、
            $は文字通りの意味になる。

\\           これの直後にある特殊文字を普通の文字として扱う。例えば、\\.なら「任意の1文字」ではなく、ピリオドそのもの
            にマッチする。このように解釈を防止することを「文字をエスケープする」という。

[]          角カッコに囲まれた文字のどれかを１文字とマッチする。例えば、[AB]はAかBにマッチし、p[aeiueo]tはpat, pet
            などにマッチする。また連続した範囲の文字を指定するなら、範囲の文字の最初と最後をハイフンでつなぐ。
            [A-Z]ならAからZまでのどんな大文字にもマッチし、[0-9]はすべての数字にマッチする。
            角カッコの中には複数の範囲を指定できるし、個別の文字と範囲を一緒に指定することも出来る。例えば、
            [:;A-Za-z()]はすべての英文字と４種類の記号にマッチする。
            角カッコ内では大半のメタキャラは特殊な意味を失うので、メタキャラを普通の文字として使いたい場合にも
            エスケープする必要はない。ただし、角カッコないでも\\, -, ]の３つのメタキャラはエスケープしなくてはならない
            。角カッコないでは(-)は範囲指定子になる。
            山形マーク(^)は角カッコ中の１文字目に置かれた場合に特殊な意味になるが、使い方が異なる。^が角カッコ中の
            最初に来た時には、このリスト中にない任意の１文字にマッチする。例えば、[^a-z]なら小文字以外の任意文字に
            ヒットする。

\\( \\)       \\(と\\)に囲まれたパターンを、特殊な格納領域(ホールドバッファ)に保存する。この方法で、１行目中に存在
            する9つまでのパターンを保存出来る。例えば、次のパターンはThatを1番のホールドバッファにいれ、thisを
            2番めのホールドバッファに入れる。 ::

                \(That\) or \(this\)

            保存したパターンは\\1~\\9というシーケンスによって置換コマンド中で再生できる。例えばThat or this を
            this or Thatという言い回しに変えたいとしたら、次のコマンドになる。 ::

                :%s/\(That\) or \(this\)/\2 or \1/

            この\\n記法は、検索文字列や置換文字列中でも使える。 ::

                :s/\(abcd\)\1/alphabet-soup/

            これによってabcdabcdがalphabet-soupに置換される。

\\< \\>       単語の先頭(\\<)と単語の末尾(\\>)にマッチする。単語の先頭や末尾は句読点か空白によって決定される。例えば、
            \\<acという式は、actionなどのように先頭にacしかつく単語錦あマッチしない。ac\\>という式では、maniacのような
            末尾にacのある単語のみにマッチする。どちらもreactにはマッチしない。\\(...\\)と違って、必ずしもこれをペアで
            使う必要はない。

~           最後の検索で使った正規表現にマッチする。例えばTheを検索した後なら、Thenは/~nで検索できる。ただし、この
            パターンは通常の/による検索でしか使えないので注意する。
========== ===========================================================================================================


POSIXのブラケット式
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
角カッコでの範囲指定子ではアルファベット以外を書くことができない。そのため、POSIX標準で[ブラケット式]が定義された。
ブラケット式の内側には、aや!などのリテラル文字だけでなく次の要素も指定出来る。

* 文字クラス
    POSIXの文字クラスは[:と:]でくくられたキーワードで構成される。このキーワードによりアルファベット文字や制御公文など様々な文字クラスが記述出来る。

    ============ =========================================================================================================
    クラス          マッチする文字
    ============ =========================================================================================================
    [:alnum:]       英数文字
    [:alpha:]       アルファベット文字
    [:blank:]       空白とタブ文字
    [:cntrl:]       制御文字
    [:digit:]       数字
    [:graph:]       印刷可能で可読な（非空白）文字
    [:lower:]       小文字
    [:print:]       印刷可能な英数文字(空白を含む)
    [:punct:]       句読記号
    [:space:]       空白文字
    [:upper:]       大文字
    [:xdigit:]      16進数
    ============ =========================================================================================================

* 照合記号
    照合記号はひとつの単位として扱う必要のある複数文字のシーケンスで、[.と.]でくくられた文字で構成される。

* 等価クラス
    等価クラスはeとフランス語のeのように同等とみなす必要のある文字集合を記述し、そのロケールにおける名称が[=と=]でくくられる。

上記のクラスはどれもブラケット式の角カッコ中に入れなければならない。例えば、 ::

    [[:alpha:]!]　は任意のアルファベット1文字かエクスクラメーションマークにマッチする。
    [[.ch.]]      は照合エレメントchにはマッチするが、単なる文字cや文字hにはマッチしない。
    [[=e=]]       をフランス語スケールで指定すれば、eなどにマッチする。

置換文字列に使うメタキャラクタ
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
一括置換する場合、上記の正規表現が特殊な意味を持つのはコマンドの検索部（最初の部分）の中だけである。だから、次のようにタイプした時、
置換文字列中の文字.と$は文字通りに扱われるので、エスケープする必要がない。 ::

    :%s/1\. Start/2.    Next, start with $100/

同様にAをaに、Bをbに、Cをcに変えようと思って次のようにタイプすると変な結果になる。 ::
    
    :%s/[ABC]/[abc]/g

置換文字列中では角カッコは普通の文字として扱われるので、このコマンドを実行すると、AやBやCが出現するたびにそれが[abc]という5文字の文字列に
変わる。この問題に対処するには、可変の置換文字列を指定する手段が必要となる。それが置換文字列で特殊な意味を持つ正規表現である。

========== ===========================================================================================================
pattern     意味
========== ===========================================================================================================
\\n         事前に\(と\)で保存しておいたn番目のパターンにマッチする。nは1~9の番号で保存された（ホールドバッファ中の)
            パターンは行の左から順に番号がつけられる。

\\          直後の文字を普通の文字として扱う。

&           置換文字列中で、検索パターンにマッチするテキスト全体を表すのに使う。テキストをタイプし直さずに済ませる。::
            
                :%s/Yazstremski/&, Carl/

            置換部分はYazstremski, Carlとなる。&は(正規表現で指定された)可変パターンの代わりにもなる。例えば、
            1から10行目をすべてカッコ内に入れたいときは次のようにする。 ::
                
                :1,10s/.*/(&)/

            この検索パターンは行全体にマッチし、ユーザーが指定したテキストとともに&によってその行が再生される。

\~          これは検索パターンに使った時と似たような意味になり、見つかった文字列が最後の置換コマンドに指定された
            置換文字列に置き換えられる。これは変種を繰り返すときに便利になる。例えば、ある行に対して、 ::

                :s/thier//their/    

            を実行しておけば、別の行でも同じ置換作業を ::

                :s/thier/~/

            として実行出来る。検索パターンの方は同じでなくてもいいので、ある行で ::

                :s/his/their/

            と実行すれば、別の行では ::

                :s/her/~/

            と実行出来る。

\\u or \\1    置換文字列中の次の文字を、それぞれ大文字または小文字に変換する。例えば、yes, doctorをYes, Doctorには ::
                
                :%s/yes, doctor/\uyes, \udoctor/

            とするが、無意味である。普通にタイプしたほうが早い。\\uと\\1はすべての正規表現同様に可変文字列で役立つ。 ::

                :%s/\(That\) or \(this\)/\2 or \1/

            この結果はthis or Thatになるが、大文字小文字の区別を調整しなければならない。そこに\\uを足す。 ::

                :%s/\(That\) or \(this\)/\u\2 or \1\1/

            \\uを使うことで、thisの最初を大文字にし、\\1を使ってThatの最初の文字を小文字にする。

\\U or \\L    \\Uと\\Lは\\uと\\1に似ているが、置換文字列の最後までか、\\eか\\Eに達するまでの全部の文字を大文字か小文字に帰る。
            \\eや\\Eが指定されていなければ、\\Uや\\Lは置換文字列の全文字に作用する。例えば、すべて大文字にするには ::

                :%s/Fortran/\UFortran/
                :%s/Fortran/\U&/        &による検索文字列の再利用
========== ===========================================================================================================

パターン検索では、必ず大文字と小文字が区別される。従って、The theの区別がある。これに対処する場合には ::

    /[tT]he

とすれば良い。

置換トリック
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* 単なる:sは:s//~/と同じで、最後の置換の繰り返しになる。ドキュメント中を移動しながら同じ変更作業を繰り返して実行する必要がある場合でかつ、
    一括置換は避けたい場合には、これによって時間とタイプ量を節約出来る。
* &を「同じこと」の意味だと考えれば、このコマンドが比較的覚えやすくなる。&のあとにgをつければ、その行のグローバル置換出来るようになる。 ::

    :%&g    最後の置換をあらゆる場所で繰り返す

* :&コマンド（最後の置換を繰り返す）を実行するviコマンドとして&キーが使える。
* :~コマンドは:&コマンドに似ているが、微妙に違う。この場合に使用される検索パターは、必ずしも最後の置換コマンドで使われたパターンではなく、
    任意のコマンドで使われた最後の正規表現になる。例えば、 ::

    :s/red/blue/
    :/green
    :~              <- :s/green/blue/に相当する

* /文字以外にもバックスラッシュとダブルクォートと縦棒(\\,",|)を除くあらゆる非アルファベット/非空白文字が区切りとして使える。これが便利なのはパス名の置換である。 ::

    :%s;/user1/tim;/home/tim;g

* edcompatibleオプションを有効にすると、最後の置換で使われたフラグ（グローバル置換用のgと確認用のc）をviが覚えていて、それを次回の置換にも適用するようになる。
    これが便利なのは、ファイル中を移動しながら一括置換をしたい場合である。1回めの置換を次のように実行すれば、 ::

        :s/old/new/g
        :set edcompatible

    これ言おうの置換コマンドは一括置換動作を実行するようになる。

    


画面分割
------------------------------------
ウィンドウ分割
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

=========   ===========================
項目名      デフォルト  
=========   ===========================
水平分割    :split  
垂直分割    :vsplit     
=========   ===========================

ウィンドウ移動
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

=========   ===========================
項目名      デフォルト  
=========   ===========================
左に移動    <C-w>h  
下に移動    <C-w>j  
上に移動    <C-w>k  
右に移動    <C-w>l  
次に移動    <C-w>w
=========   ===========================

ウィンドウそのものを移動
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

=========   ===========================
項目名      デフォルト  
=========   ===========================
左に移動    <C-w>H  
下に移動    <C-w>J  
上に移動    <C-w>K  
右に移動    <C-w>L  
回転        <C-w>r
=========   ===========================

カレントウィンドウの大きさを変更
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

===============   ===========================
項目名               デフォルト  
===============   ===========================
縦に最大化           <C-w>_  
横に最大化           <C-w>パイプ     
大きさを揃える       <C-w>= 
幅を増やす           <C-w>>  
幅を減らす           <C-w><  <
高さを増やす         <C-w>+  +
高さを減らす         <C-w>-  
===============   ===========================

タブ関連
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

==============   ===========================
項目名              デフォルト  
==============   ===========================
新規タブ            :tabnew     
次のタブに切替      gt  
前のタブに切替      gT  
==============   ===========================

閉じる
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

==================   ===========================
項目名                  デフォルト  
==================   ===========================
ウィンドウを閉じる      :q  
バッファを閉じる        :bd
==================   ===========================

http://qiita.com/tekkoc/items/98adcadfa4bdc8b5a6ca


Xmlファイルの整形
------------------------------------
    :%s/></>\r</g | filetype indent on | setf xml | normal gg=G

その他
------------------------------------
Unixコマンドを実行したくなった場合は、 ::
    
    :!command

で実行出来る。enterですぐに戻ることが出きるが、いくつか実行したい場合は、次のexコマンドでシェルを起動すればいい。 ::

    :sh

シェルを終了して戻りたい問いは、Ctrl+Dで戻れる。
また、:readをUnixの呼び出しと組み合わせれば、Unixコマンドの結果を自分のファイルに読み込めるようになる。単純な例としては、 ::

    :r !date
    Sat Dec  3 16:32:25 JST 2016

こうすれば、システム日時情報が自分のファイルのテキスト中に読み込まれる。:rコマンドの前に行アドレスをつければ、コマンドの結果をファイル中の好きな位置に挿入出来る。
指定しなければ、カレント行に読み込まれる。
他と手羽、ファイル編集中に別のファイルを読み込みたいとする。test.txtの中身は ::

    Yoji    23
    Ami     17
    Yuko    50

となっている。この場合、以下のコマンドを実行すれば、 ::

    :r !sort test.txt
    Ami     17
    Yoji    23
    Yuko    50

となり、ファイルの中身がソートして挿入される。また、この名簿が別のファイルではなく、現在のファイルの96から98行目にはいっているとする。この時は、 ::

    :96,98!sort

でフィルタ処理結果を得ることが出来る。

zip
====================================

zipコマンドでディレクトリをzip化する
------------------------------------
    $ zip -r 生成するzipファイル名 zip化するディレクトリ

MeCab
====================================

インストール
------------------------------------
インストール方法を以下に示す。 ::

    git clone https://github.com/taku910/mecab.git
    cd mecab/mecab
    ./configure --enable-utf8-only
    make 
    make check
    sudo make install

インストールが終わると、mecabが配置される。 ::

    /usr/local/etc/mecabrc
    /usr/local/bin/mecab
    /usr/local/etc/mecab-config

辞書のダウンロードを続けて行う。 ::
    
    cd ../macab-ipadic
    ./configure --with-charset=utf8
    make 
    sudo make install

この時点でコンソールからmecabを起動し、使用することが出来る。
pythonで使用する場合を次に示す。 ::

    pip install mecab-python3

これでpythonから使えるはずであるが、トラブルがあったため、それについて示す。pythonからimportした際に、
libmecab.so.2が存在しないというエラーが生じた。ファイルがあるかを確認する。 ::

    $ ls /usr/local/lib/libmecab.so.2
    /usr/local/lib/libmecab.so.2

ld.so.confに/usr/local/libを追記する。 ::

    $ vim /etc/ld.so.conf

修正後ファイル ::

    include ld.so.conf.d/*.conf
    /usr/local/lib

ld.so.confの設定を反映する。 ::
    
    $ sudo ldconfig

反映後にpythonから使用出来る。

http://qiita.com/saicologic/items/ab70e14f7e2ec2ee0b4d

標準の辞書ではなくて、随時更新される辞書を使う方がいい。ただし、インストールにメモリ2GB以上必要。
https://github.com/neologd/mecab-ipadic-neologd/blob/master/README.ja.md

nkf
====================================
日本語の処理を行うコマンドのインストールについて示す。 ::

    wget http://jaist.dl.sourceforge.jp/nkf/48945/nkf-2.1.1.tar.gz
    tar xzvf nkf-2.1.1.tar.gz
    cd nkf-2.1.1
    make 
    # /usr/localの中のbinとmanにインストールされる。
    make install

nkfで文字コードを確認する。 ::

    $ nkf -g ikinokozo.txt
    Shift_JIS(CR)

Shift_JISからUTF-8に変更する。 ::

    $ nkf -w --overwrite ikinokozo.txt

UTF-8に変更されたか確認する。 ::

    $ nkf -g ikinokozo.txt
    UTF-8(CR)


github
====================================
Gitとは
------------------------------------
Gitはバージョン管理システム(Version Control Sytem)であり、ファイルの履歴を管理するシステムである。何らかのサ行によって生成されたファイルについて複数の履歴(バージョン)を記録し、
あとから、古いバージョンの取り出しや差分の参照が出来る仕組みである。このファイルの履歴をリポジトリ、履歴の一つひとつをコミットと呼び、履歴をリポジトリに追加や登録することを
コミットと呼ぶ。

バージョン管理システムは、複数人数で同一のファイルを編集する必要がある時に、その力を発揮する。例えば、テキストファイルをサーバにおいて共有していたとする。この状態で編集やコピーを続けていると、
誰が最新版を持っているのかやどこを変更したのかなどの履歴が分からなくなってします。ここでのバージョン管理システムを導入すると、変更点と変更者、変更日時を管理出きるようになる。

VCSは個別バージョン管理システム、クライアント・サーバ型の集中型バージョン管理システム、分散型バージョン管理システムの3種類あり、Gitは分散型である。

事前知識
------------------------------------
リポジトリとは、ファイルやディレクトリの状態を保存する場所である。
更履歴を管理したいディレクトリなどをリポジトリの管理下に置くことで、そのディレクトリ内のファイルなどの変更履歴を記録することができる。

* ローカルリポジトリ・・・ 自分のマシン内にあるリポジトリ
* リモートリポジトリ・・・ サーバなどネットワーク上にある。

基本的にローカルリポジトリで作業を行い、その作業内容をリモートポジトリへプッシュする流れで行う。

* コミット・・・ファイルの追加や変更の履歴をリポジトリに保存すること
* プッシュ・・・ファイルの追加や変更の履歴をリモートリポジトリにアップロードするための操作

ブランチ(branch)とは現在リリースしているバージョンのメンテナンスをしながら新たな機能の追加やバグ修正を平行して行うため、
複数のバージョン管理を行うためにbranchがある。branchは履歴の流れを分岐して記録していくものであり、分岐したブランチは、他のブランチの影響を受けないため、
同じリポジトリ内でそれぞれの開発を行える。

githubとssh接続
------------------------------------
ssh公開鍵を作成するために、::

    $ ssh-keygen

を実行する。Enter passphraseと表示されるので、パスフレーズを入力する。(二回)

公開鍵を確認するために、::

    $ cat ~/.ssh/id_rsa.pub

を実行する。ssh-rsaから始まるめちゃくちゃな文字列が公開鍵であるので、これをまるごとコピーする。

GitHubサイトのアカウントセッティング画面上にSSH Keysという項目があるので、そこで、先ほどの鍵を追加する。
コピーしたものまるごと貼り付ける。

端末に戻り、gitにユーザ名を登録する。::

    $ git config --global user.name {username}
    $ git config --global user.mail {mail address}

登録状況を確認するには、::

    $ git config --global --list

GitHubでレポジトリを作成する。
------------------------------------
まずは、リポジトリを作成する。GitHubにログインした状態で、右下の「New Repository」ボタンを押す。
次に表示される画面で、「Repository name」の入力後に「Description」も入力する。

また、リポジトリの種類をPublicかPrivateを選択する。最後にリポジトリの中にあらかじめREADMEファイルを作成しておく場合は、
「Initialize this repository with a README」にチェックを入れる。.gitignoreやlicenseについては後で追加や変更ができるため、Noneとする。

必要項目の入力が終わり、「Create repository」ボタンをクリックするとリポジトリの作成は完了する。
次の画面でリモートリポジトリのアドレスが表示されるため、控えておく。

ローカルリポジトリ
------------------------------------
ローカルディレクトリを作成し、そこを初期化する。::

    mkdir hoge
    cd $_
    git init

「git init」コマンドはgitリポジトリを新たに作成するコマンドである。バージョン管理を行っていない既存のプロジェクトをgitリポジトリに変換する場合や、
空の新規リポジトリを作成して初期化する場合に使用する。このコマンドの実行によりカレントディレクトリをgitリポジトリに変換する。

GitHubのリモート先を指定
------------------------------------
foo を github のユーザ名、bar をプロジェクト名で、それぞれ置き換える。::

    $ git remote add origin git@github.com:foo/bar.git

ファイルの作成・変更・削除をgitのインデックスに追加する(git add)
------------------------------------------------------------------------
ファイルを追加したあと、gitのバージョン管理に追加するには、以下のコマンドでインデックスに追加する。::

    $ git add foo

インデックスとは、リポジトリにコミット準備をするために、変更内容を一時的に保存する場所である。

変更結果をローカルリポジトリにコミットする(git commit)
------------------------------------------------------------------------
インデックスに追加されたファイルをコミットする。
コミットとは、ファイルやディレクトリの追加や変更をリポジトリに記録する操作のことである。::

    git commit -m "add a new file"

これでリポジトリに対してファイルの追加が記録された。確認は以下の方法でできる。::

    git status

リモートリポジトリに反映される前に、リモートリポジトリの情報を追加する。
この情報はgithub所に表示されるリモートリポジトリのアドレスである。例として、::

    git remote add origin https://github.com/hoge/foo.git


ローカルリポジトリをプッシュしてリモートレポジトリへ反映させる(git push)
------------------------------------------------------------------------
ローカルリポジトリの変更をgithub上にあるリモートリポジトリに反映させるため、以下のようにする。::

    git push origin master

GitHubのユーザ名とパスワードを尋ねられるため、入力する。これが終わると、リモートレポジトリへ反映出来る。

GitHub新規リポジトリの場合
---------------------------------------------
以下転載::

    echo "# mydocs" >> README.md
    git init
    git add README.md
    git commit -m "first commit"
    git remote add origin https://github.com/Swall0w/mydocs.git
    git push -u origin master

GNU Parallel
====================================
GNU Parallelとは、

* 並列実行関係の機能が詰まったユーティリティ
* 便利なソフトだが、マニュアルが不親切

使い方パターン例
---------------------------------------------

1. 小さなファイルが超大量、それぞれに処理
    ex. Wikipediaのすべての記事に処理など

2. 巨大なファイルに各行に処理
    ex. ツイートログファイル(1ファイル数GB)

3. パラメータとその組み合わせが大量
    ex. 機械学習(次元数、層数、学習率など)

参考(https://bitbucket.org/cl-tohoku/bakapara_tutorial)


1. 処理すべきファイルがたくさん
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
大量のファイルに定型的な処理

-> GNU Parallelのファイル名置換を使う ::

    ls orig/* | parallel -j 10 "mecab < {} > processed/{/}"

    1. ls orig/* : 処理するファイルのリストを生成
    2. parallel -j 10 : 並列数
    3. "mecab < {} : {}がファイル名に置換される。(ex. org/1.txt)
    4. > processed/{/} : {/}はファイル名からディレクトリを除いたもの(ex. org/1.txt -> 1.txt)
    トータルとして、org/ディレクトリ以下の全てのファイルに対して並列でmecabを実行し、processed/以下に出力する。

2. 大きなファイルの全ての行に
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1つのファイルの100万行とかに行ごとに処理

-> --pipe オプションを使う ::

    cat original.txt | parallel --pipe --L 10000 "hoge.py" > processed.txt

    トータルとして、original.txtを1万行づつの「塊」に分解して、それぞれを並列にhoge.pyにパイプで入力する。
    その結果をprocessed.txtにまとめる。

ボトルネックの部分飲みを並列化することも出来る。

--pipeの真髄：パイプラインの一部を並列化 ::

    cat a.txt | hoge.py | fuga.py | piyo.py > b.txt 
    において、hoge.py , piyo.pyは早いが、 fuga.pyが遅い時(ボトルネックの時)
    ->
    cat a.txt | hoge.py | parallel --pipe --L 100 fuga.py | piyo.py > b.txt 
    でfuga.pyのみを並列化して高速化

ちなみに、ボトルネックのプロファイリングはpv(pipe-viewer)コマンドを用いる。

3. 試すパラメータがたくさん
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
例えば、学習率、層数、ユニット数など全ての組み合わせを試したい時

-> GNU Parallelの組み合わせ展開(:::)を使う ::

    lr=(0 0.05 0.1 0.5 1.0 5)   # 学習率
    units=(100 200 300 400)     # 隠れ層ユニット数

    parallel " train.py --lr={1} --units={2} > log/{1}_{2}.txt" \
        ::: ${lr[@]} ::: ${units[@]}

3行でかけるが、シェルスクリプトにしても可

注意点
---------------------------------------------
* timeコマンドで小まめに計測をする。(パイプ並列が多い場合早くならないこともある。)
* IO/メモリが重い処理は控えめな並列数で行う
* 長時間専有する場合は-niceオプションをつける
* ちゃんと実行する前に、まずは **--dry-run** オプションをつけて実行(どんなコマンドが実行されるかを教えてくれる)
* --bar : 進捗状況を表示、残り時間推定を出してくれるので、使えるときは使う
* -S : マシンをまたいだ並列処理を行ってくれる。
* 並列数は **-j** オプションで指定、デフォルトではCPU数

シェルスクリプト
====================================
引数
---------------------------------------------
引数処理に使用する変数
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
シェルスクリプト実行時に指定された引数は1パラメータと呼ばれる特殊な変数に設定される。
シェルスクリプト内からはこの変数を参照することで、引数を処理することが可能になる。
位置パラメータ以外にも、引数の処理に関連した特殊な変数がある。

========= =======================================================================================================================================
変数名      自動的に設定される値
========= =======================================================================================================================================
$#          実行時に指定された引数の値を表す変数。"$ ./test.sh hoge piyo poyo"と実行した場合、
            シェルスクリプトないで変数 **$#** を参照すると値は3となる。
$@          シェルスクリプト実行時、もしくは **set** コマンド実行時に指定された全パラメータが
            設定される変数。変数 **$*** と基本同じだが、""で囲んだ時の動作が異なる。
$*          シェルスクリプト実行時、もしくは **set** コマンド実行時に指定された全パラメータが
            設定される変数。変数 **$@** と基本同じだが、""で囲んだ時の動作が異なる。
$0          実行時のコマンド名が設定される変数。"$ ./test.sh"として実行した場合には"./test.sh"が、
            "/home/user/test.sh"として実行した場合には"/home/user/test.sh"が設定される。
$1-$n       シェルスクリプト実行時に指定した引数の値がそれぞれ設定される変数。1番目に指定した引数は
            $1に、2番めに指定した引数は、$2に、n番目に指定した引数は$nに設定される。10番目以降の
            引数参照時には${10}のように{}を使用する必要がある。これは$10を$1 "0"のように誤解釈を
            防止するためである。
========= =======================================================================================================================================

指定された引数の数をチェックする
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
